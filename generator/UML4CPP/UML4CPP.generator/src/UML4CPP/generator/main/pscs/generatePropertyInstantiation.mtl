[comment encoding = UTF-8 /]
[**
 * Copyright (c) 2017 TU Ilmenau, Systems and Software Engineering Group
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), 
 * to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 ****************************************************************************************************************************************************************
 * 
 * module to generate property instantiation code conforming to PSCS instantiation semantics
 * 
 */]
[module generatePropertyInstantiation('http://www.eclipse.org/uml2/5.0.0/UML')]

[import UML4CPP::generator::main::components::generateType /]
[import UML4CPP::generator::main::helpers::nameHelper /]
[import UML4CPP::generator::main::helpers::generalHelper /]
[import UML4CPP::generator::main::components::generateClass /]
[import UML4CPP::generator::main::components::generateProperty /]


[**
 * Template for generation of property instatiation (parts & ports) of composite structures
*/]
[template public generateAttributeInstantiation(aProperty : Property) ? (not isUnion()) post(trim())]
[if (aProperty.upper = 1)]
	[if (aProperty.canInstantiate() and (not aProperty.type.oclIsTypeOf(Interface)))]
//instantiate [aProperty.eClass().name/] '[aProperty.name/]'
		[if (aProperty.isComposite())]
m_[aProperty.name/] = [aProperty.type._package.generateNamespace(false)/]::[aProperty.type._package.getPackageName()/]Factory::eInstance()->create[aProperty.type.name.toUpperFirst()/]_as_[aProperty.name/]_in_[aProperty.getFeaturingClassifier().name.toUpperFirst()/]([if (aProperty.isBackReference())]m_this[aProperty.getFeaturingClassifier().name.toUpperFirst()/]Ptr[else]getThis[aProperty.getFeaturingClassifier().name.toUpperFirst()/]Ptr()[/if]);
			[if (aProperty.oclIsTypeOf(Port))]
m_[aProperty.name/]->setDefiningPort([aProperty.generatePackageGetterCall()/]);
			[/if]
		[else]
m_[aProperty.name/] = [aProperty.type._package.generateNamespace(false)/]::[aProperty.type._package.getPackageName()/]Factory::eInstance()->create[aProperty.type.name.toUpperFirst()/]();
		[/if]
this->getLocus()->add(m_[aProperty.name/]);
m_[aProperty.name/]->constructObject([aProperty.type.generatePackageGetterCall()/]);
	[/if]
[elseif (aProperty.canInstantiate())]
//instantiate [aProperty.eClass().name/] '[aProperty.name/]'
[aProperty.generateContainerPropertyInit()/]
	[if (aProperty.getUpper() <> 1 and aProperty.getLower() > 0 and (not aProperty.type.oclIsTypeOf(Interface)))]
for(unsigned int i = 1; i <= [aProperty.getLower()/]; i++)
{
	[aProperty.generatePartInstantiation()/]
}
	[/if]
[/if]
[/template]


[**
 * Template for generation of instantiation of a part
*/]
[template private generatePartInstantiation(aProperty : Property) post(trim())
{
	aPackage : Package = aProperty.type.getNearestPackage(); 
	factoryName : String = aPackage.name.concat('Factory');
}]
[if (aProperty.isComposite)]
std::shared_ptr<[aProperty.type.transformType()/]> value = [aPackage.generateNamespace(false)/]::[factoryName/]::eInstance()->create[aProperty.type.name.toUpperFirst()/]_as_[aProperty.name/]_in_[aProperty.getFeaturingClassifier().name.toUpperFirst()/]([if (aProperty.isBackReference())]m_this[aProperty.getFeaturingClassifier().name.toUpperFirst()/]Ptr[else]getThis[aProperty.getFeaturingClassifier().name.toUpperFirst()/]Ptr()[/if]);
	[if (aProperty.oclIsTypeOf(Port))]
value->setDefiningPort([aProperty.generatePackageGetterCall()/]);
	[/if]
[else]
std::shared_ptr<[aProperty.type.transformType()/]> value = [aPackage.generateNamespace(false)/]::[factoryName/]::eInstance()->create[aProperty.type.name.toUpperFirst()/]();
m_[aProperty.name/]->add(value);
[/if]
this->getLocus()->add(value);
value->constructObject([aProperty.type.generatePackageGetterCall()/]);
[/template]

[**
 * generate attribute member initialization for properties with OpaqueExpression as default value
*/]
[template public generateAttributeDefaultInstantiation(aProperty : Property) ? (aProperty.defaultValue.oclIsTypeOf(OpaqueExpression)) post(trim()) 
{expression : OpaqueExpression = aProperty.defaultValue.oclAsType(OpaqueExpression);}]
[comment PSCS only supports to compute values from default values that are OpaqueExpressions using OpaqueExpression::behavior /]
[let expressionBehavior : Behavior = expression.behavior]
[if (not expressionBehavior.oclIsUndefined())]
//instantiate [aProperty.eClass().name/] '[aProperty.name/]' with opaque expression [if (not expression.name.oclIsUndefined())]'[expression.name/]'[else]anonymous opaque expression[/if]
{
	[if (expressionBehavior.oclIsTypeOf(Activity))]
	[generateOpaqueExpressionEvaluationFromActivity(aProperty, expressionBehavior.oclAsType(Activity))/]
	[elseif (expressionBehavior.oclIsKindOf(OpaqueBehavior))]
	[generateOpaqueExpressionEvaluationFromOpaqueBehavior(aProperty, expressionBehavior.oclAsType(OpaqueBehavior))/]
	[else]
	// Cannot instatiate default value for [aProperty.eClass().name/] [aProperty.memberName()/] because opaque expression behavior of type [expressionBehavior.eClass().name/] is currently not supported.
	[/if]
}
[/if]
[/let]
[/template]

[template private generateOpaqueExpressionEvaluationFromActivity(aProperty : Property, anActivity : Activity) post(trim())]
std::shared_ptr<Any> expressionResult;
[if (not anActivity.specification.oclIsUndefined())]
	[if (anActivity.specification.oclIsKindOf(Operation))]
		[let specifiedOperation : Operation = anActivity.specification.oclAsType(Operation)]
// Activity [anActivity.generateNamespaceName(true)/] specifies Operation [specifiedOperation.generateNamespaceName(true)/]
expressionResult = this->invokeOperation([specifiedOperation.getNearestPackage().generateNamespace(true)/]::[specifiedOperation.getNearestPackage().getPackageName()/]Package::[specifiedOperation.getMemberName().toUpperCase()/], new Bag<Any>(), new Bag<Any>());
		[/let]
	[/if]
[else]
std::shared_ptr<PluginFramework> pluginFramework = PluginFramework::eInstance();
std::string pluginName = "[anActivity.getRootPackage().getPackageName()/]Exec";
std::shared_ptr<MDE4CPPPlugin> plugin = pluginFramework->findPluginByName(pluginName);
if (plugin)
{
	DEBUG_INFO("Plugin '" << plugin->eNAME() << "' found.")

	std::shared_ptr<UMLExecutionModelPlugin> executionPlugin = std::dynamic_pointer_cast<UMLExecutionModelPlugin>(plugin);
	if (executionPlugin)
	{
		DEBUG_INFO("Execution plugin '" << executionPlugin->eNAME() << "' is accessable.")
		expressionResult = executionPlugin->executeActivity([anActivity.generatePackageGetterCall()/], std::shared_ptr<Bag<Any>>(new Bag<Any>()), nullptr);
	}
	else
	{
		std::cout << "Plugin '" << plugin->eNAME() << "' is not an execution plugin!" << std::endl;
	}
}
else
{ 
	std::cout << "Plugin '" << pluginName << "' not found!" << std::endl;
}
[/if]
[if (aProperty.type.oclIsKindOf(PrimitiveType) or aProperty.type.oclIsKindOf(Enumeration))]
m_[aProperty.name/] = expressionResult->get<[aProperty.generateCppType()/]>();
[else]
	[if (aProperty.upper <> 1)]
std::shared_ptr<Bag<uml::Element>> elementList = retrieveAnyValueAsUMLElementContainer(expressionResult);
const [aProperty.generateCppType()/]& _[aProperty.name.toLowerFirst()/] = this->[aProperty.getterName()/]();
for(const std::shared_ptr<uml::Element>& element : * elementList)
{
		[if (aProperty.oclIsTypeOf(Port))]
	[aProperty.type.generateCppRawType(false)/] value = std::dynamic_pointer_cast<[aProperty.type.generateCppRawType(true)/]>(element);
	value->setDefiningPort([aProperty.generatePackageGetterCall()/]);
	_[aProperty.name.toLowerFirst()/]->add(value;)
		[else]
	_[aProperty.name.toLowerFirst()/]->add(std::dynamic_pointer_cast<[aProperty.type.generateCppRawType(true)/]>(element));
		[/if]
}
	[else]
m_[aProperty.name/] = std::dynamic_pointer_cast<[aProperty.type.generateCppRawType(true)/]>(retrieveAnyValueAsUMLElement(expressionResult));
		[if (aProperty.oclIsTypeOf(Port))]
m_[aProperty.name/]->setDefiningPort([aProperty.generatePackageGetterCall()/]);
		[/if]
	[/if]
[/if]
[/template]

[template private generateOpaqueExpressionEvaluationFromOpaqueBehavior(aProperty : Property, anOpaqueBehavior: OpaqueBehavior) post(trim())]
std::shared_ptr<Any> expressionResult;
[if (not anOpaqueBehavior.specification.oclIsUndefined())]
	[if (anOpaqueBehavior.specification.oclIsKindOf(Operation))]
		[let specifiedOperation : Operation = anOpaqueBehavior.specification.oclAsType(Operation)]
// OpaqueBehavior [anOpaqueBehavior.generateNamespaceName(true)/] specifies Operation [specifiedOperation.generateNamespaceName(true)/]
expressionResult = this->invokeOperation([specifiedOperation.getNearestPackage().generateNamespace(true)/]::[specifiedOperation.getNearestPackage().getPackageName()/]Package::[specifiedOperation.getMemberName().toUpperCase()/], std::shared_ptr<Bag<Any>>(new Bag<Any>()), std::shared_ptr<Bag<Any>>(new Bag<Any>()));
		[/let]
	[/if]
	[comment 
		Else if the OpaqueBehavior has no specification (i.e. it does not implement any Operation)
		but it has a defined context and this context is a class,
		then execute this Behavior on the corresponding context object
	/]
[elseif ((not anOpaqueBehavior._context.oclIsUndefined()) and anOpaqueBehavior._context.oclIsTypeOf(Class))]
// OpaqueBehavior [anOpaqueBehavior.generateNamespaceName(true)/] has Class [anOpaqueBehavior._context.generateNamespaceName(true)/] as its context
expressionResult = context->invokeOpaqueBehavior([anOpaqueBehavior.getNearestPackage().generateNamespace(true)/]::[anOpaqueBehavior.getNearestPackage().getPackageName()/]Package::[anOpaqueBehavior.getMemberName().toUpperCase()/], std::shared_ptr<Bag<Any>>(new Bag<Any>()), std::shared_ptr<Bag<Any>>(new Bag<Any>()));
	[comment 
		Else execute the global model function corresponding to this Behavior
	/]
[else]
// OpaqueBehavior [anOpaqueBehavior.generateNamespaceName(true)/] has [if (anOpaqueBehavior._context.oclIsUndefined())]no context[else][anOpaqueBehavior._context.eClass().name/] [anOpaqueBehavior._context.generateNamespaceName(true)/] as its context[/if]
// and is therefore realized as a global function
expressionResult = [anOpaqueBehavior.getNearestPackage().generateNamespace(true)/]::invoke([anOpaqueBehavior.getNearestPackage().generateNamespace(true)/]::[anOpaqueBehavior.getNearestPackage().getPackageName()/]Package::[anOpaqueBehavior.getMemberName().toUpperCase()/], std::shared_ptr<Bag<Any>>(new Bag<Any>()), std::shared_ptr<Bag<Any>>(new Bag<Any>()));
[/if]
m_[aProperty.name/] = expressionResult->get<[aProperty.generateCppType()/]>();
[if (aProperty.oclIsTypeOf(Port))]
m_[aProperty.name/]->setDefiningPort([aProperty.generatePackageGetterCall()/]);
[/if]
[/template]

[**
 * generate attribute member initialization for properties with InstanceValue as default value
*/]
[template public generateAttributeDefaultInstantiation(aProperty : Property) ? (aProperty.defaultValue.oclIsTypeOf(InstanceValue)) post(trim()) 
{instVal : InstanceValue = aProperty.defaultValue.oclAsType(InstanceValue);}]
[if (not instVal.type.oclIsTypeOf(Enumeration))] [comment Default values for Enumerations are assigned ad-hoc in class header file /]
[aProperty.generateAttributeInstantiation()/]
[let specification : InstanceSpecification = instVal.instance]
//instantiate [aProperty.eClass().name/] '[aProperty.name/]' with specification [if (not specification.name.oclIsUndefined())]'[specification.name/]'[else]anonymous instance specification[/if]
	[if (aProperty.upper <> 1)] [comment *-multiplicity /]
for(unsigned int i = 0; i < [aProperty.lower/]; i++)
{
		[for (aSlot : Slot | specification.slot)]
	[aSlot.generateSlotInitialization('m_'.concat(aProperty.name).concat('->at(i)'), 0)/]
		[/for]
}
	[else] [comment 1-multiplicity /]
	[for (aSlot : Slot | specification.slot)]
[aSlot.generateSlotInitialization('m_'.concat(aProperty.name), 0)/]
	[/for]
	[/if]
[/let]
[/if]
[/template]

[template private generateSlotInitialization(aSlot : Slot, recursiveString : String, recursionDepth : Integer) post(trim())]
[if (aSlot.definingFeature.type.isPrimitive())]
[aSlot.generatePrimitiveSlotInitialization(recursiveString)/]
[else]
[aSlot.generateNonPrimitiveSlotInitialization(recursiveString, recursionDepth)/]
[/if]
[/template]

[template private generateNonPrimitiveSlotInitialization(aSlot : Slot, recursiveString : String, recursionDepth : Integer) post(trim())
{
	instValue : InstanceValue = aSlot.value->first().oclAsType(InstanceValue); 
	instSpec : InstanceSpecification = instValue.instance; 
	feature : Property = aSlot.definingFeature.oclAsType(Property)
}]
[if (aSlot.definingFeature.getUpper()<>1)]
for(unsigned int i_[recursionDepth/] = 0; i_[recursionDepth/] < [feature.lower/]; i_[recursionDepth/]++)
{
	[for (aNestedSlot : Slot | instSpec.slot)]
	[aNestedSlot.generateSlotInitialization(recursiveString.concat('->get'.concat(feature.name.toUpperFirst()).concat('()->at(i_'.concat(recursionDepth.toString()).concat(')'))), recursionDepth+1) /]
	[/for]
}
[else]
[for (aNestedSlot : Slot | instSpec.slot)]
[aNestedSlot.generateSlotInitialization(recursiveString.concat('->get'.concat(feature.name.toUpperFirst()).concat('()')), recursionDepth) /]
[/for]
[/if]
[/template]

[**
 * generate instantiation of a slot of an instance specification
*/]
[template private generatePrimitiveSlotInitialization(aSlot : Slot, recursiveString : String) post(trim())]
[if (aSlot.definingFeature.getUpper() <> 1)]
[aSlot.initPrimitiveValueFromMultipleLiteralSpecifications(recursiveString)/]
[else]
[aSlot.initPrimitiveValueFromSingleLiteralSpecification(recursiveString)/]
[/if]
[/template]

[**
 * generate call of attribute setter to set value (upper = 1) as defined by Slot
*/]
[template private initPrimitiveValueFromSingleLiteralSpecification(aSlot : Slot, recursiveString : String) post(trim())]
[let slotType : String = aSlot.definingFeature.type.name]
[if (slotType = 'Boolean' or slotType = 'EBoolean')][recursiveString/]->set[aSlot.definingFeature.name.toUpperFirst()/]([aSlot.value->first().oclAsType(LiteralBoolean).value/]);
[elseif (slotType = 'UnlimitedNatural')][recursiveString/]->set[aSlot.definingFeature.name.toUpperFirst()/]([aSlot.value->first().oclAsType(LiteralUnlimitedNatural).value/]);
[elseif (slotType = 'Integer' or slotType = 'EInt')][recursiveString/]->set[aSlot.definingFeature.name.toUpperFirst()/]([aSlot.value->first().oclAsType(LiteralInteger).value/]);
[elseif (slotType = 'Real' or slotType = 'EDouble' or slotType = 'EFloat')][recursiveString/]->set[aSlot.definingFeature.name.toUpperFirst()/]([aSlot.value->first().oclAsType(LiteralReal).value/]);
[elseif (slotType = 'String' or slotType = 'EString')][recursiveString/]->set[aSlot.definingFeature.name.toUpperFirst()/]("[aSlot.value->first().oclAsType(LiteralString).value/]");
[elseif (aSlot.definingFeature.type.oclIsKindOf(Enumeration))][recursiveString/]->set[aSlot.definingFeature.name.toUpperFirst()/]([aSlot.definingFeature.type.qualifiedName/]::[aSlot.value.oclAsType(InstanceValue).instance.name.toUpper()/]);
[/if]
[/let]
[/template]

[**
 * generate call of attribute setter to set values (upper != 1) as defined by Slot
*/]
[template private initPrimitiveValueFromMultipleLiteralSpecifications(aSlot : Slot, recursiveString : String) post(trim())]
[let slotType : String = aSlot.definingFeature.type.name]
[for (aValueSpecification : ValueSpecification | aSlot.value)]
[if (slotType = 'Boolean' or slotType = 'EBoolean')][recursiveString/]->get[aSlot.definingFeature.name.toUpperFirst()/]()->add([aValueSpecification.oclAsType(LiteralBoolean).value/]);
[elseif (slotType = 'UnlimitedNatural')][recursiveString/]->get[aSlot.definingFeature.name.toUpperFirst()/]()->add([aValueSpecification.oclAsType(LiteralUnlimitedNatural).value/]);
[elseif (slotType = 'Integer' or slotType = 'EInt')][recursiveString/]->get[aSlot.definingFeature.name.toUpperFirst()/]()->add([ aValueSpecification.oclAsType(LiteralInteger).value/]);
[elseif (slotType = 'Real' or slotType = 'EDouble' or slotType = 'EFloat')][recursiveString/]->get[aSlot.definingFeature.name.toUpperFirst()/]()->add([aValueSpecification.oclAsType(LiteralReal).value/]);
[elseif (slotType = 'String' or slotType = 'EString')][recursiveString/]->get[aSlot.definingFeature.name.toUpperFirst()/]()->add("[aValueSpecification.oclAsType(LiteralString).value/]");
[elseif (aSlot.definingFeature.type.oclIsKindOf(Enumeration))][recursiveString/]->get[aSlot.definingFeature.name.toUpperFirst()/]()->add([aSlot.definingFeature.type.qualifiedName/]::[aValueSpecification.oclAsType(InstanceValue).instance.name.toUpper()/]);
[/if]
[/for]
[/let]
[/template]




[query public getInterfaceRealizations(aPackage : Package, anInterface : Interface) : Set(InterfaceRealization) = aPackage.allOwnedElements()->selectByType(InterfaceRealization)->reject(not (contract.name = anInterface.name))/]

[query public canInstantiate(aProperty : Property) : Boolean = 
if (aProperty.isComposite()) then
	if(aProperty.oclIsKindOf(TypedElement)) then
		if(aProperty.type.oclIsTypeOf(Class)) then
			not aProperty.type.oclAsType(Class).isAbstract 
		else if (aProperty.type.oclIsTypeOf(Interface)) then
			aProperty.oclIsTypeOf(Port)
			else false
			endif
		endif
	else false
	endif
else false
endif
/]
