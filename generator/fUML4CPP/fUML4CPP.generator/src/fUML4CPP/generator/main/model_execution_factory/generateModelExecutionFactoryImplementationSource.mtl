[comment encoding = UTF-8 /]
[**
 * Copyright (c) 2017 TU Ilmenau, Systems and Software Engineering Group
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), 
 * to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */]
[module generateModelExecutionFactoryImplementationSource('http://www.eclipse.org/uml2/5.0.0/UML')]

[import fUML4CPP::generator::main::helpers::fUMLCollectionHelper /]
[import fUML4CPP::generator::main::pssm::generatePssmExecutionPrototypes /]

[import UML4CPP::generator::main::helpers::generalHelper /]
[import UML4CPP::generator::main::helpers::nameHelper /]
[import UML4CPP::generator::main::model_execution::model_execution /]
[import UML4CPP::generator::main::profiles::uml4CPPProfileHelper /]

[template public generateModelExecutionFactoryImplementationSource(aPackage : Package)
{
packageName : String = aPackage.getPackageName().sanitize(); 
originalName : String = aPackage.generateNamespacePath(false);
}]
[file (originalName.concat('Exec/impl/') + packageName.concat('ExecutionFactoryImpl.cpp'), false, 'UTF-8')]
#include "[packageName/]ExecutionFactoryImpl.hpp"
#include <iostream>

[defineDebugMacro()/]

//Model includes
[for (activitySmPackage : Package | aPackage.collectActivitiesOwnedByPackage()->union(aPackage.collectStateMachinesOwnedByPackage())->reject(isDoNotGenerateElement()).getNearestPackage()->asSet()->sortedBy(myQualifiedName()))]
#include "[activitySmPackage.generateNamespacePath(false)/]/[activitySmPackage.getPackageName()/]Package.hpp"
[/for]

//fUML includes
[if (aPackage.includesFUML())]
#include "fUML/Semantics/Actions/ActionsFactory.hpp"
#include "fUML/Semantics/Activities/ActivitiesFactory.hpp"
#include "fUML/Semantics/Activities/ActivityExecution.hpp"
#include "fUML/Semantics/Activities/ActivityNodeActivationGroup.hpp"
[/if]
#include "fUML/Semantics/Loci/Locus.hpp"
[for (anIncludeString : String | 
	aPackage.collectActivitiesOwnedByPackage()->reject(isDoNotGenerateElement()).node
	->addAll(aPackage.collectActivitiesOwnedByPackage()->reject(isDoNotGenerateElement()).node->filter(Action).input)
	->addAll(aPackage.collectActivitiesOwnedByPackage()->reject(isDoNotGenerateElement()).node->filter(Action).output)
	->addAll(aPackage.collectStructuredActivityNodesOwnedByPackage()->reject(isDoNotGenerateElement()).node)
	->addAll(aPackage.collectStructuredActivityNodesOwnedByPackage()->reject(isDoNotGenerateElement()).node->filter(Action).input)
	->addAll(aPackage.collectStructuredActivityNodesOwnedByPackage()->reject(isDoNotGenerateElement()).node->filter(Action).output)
	.generateCorrespondingActivityNodeActivationInclude()->asSet()) before('//ActivityNodeActivation includes\n')]
[anIncludeString/]
[/for]
[if (isPSCSExecutable())]
#include "PSCS/Semantics/Actions/ActionsFactory.hpp"
[/if]
[if (aPackage.includesPSSM())]

//PSSM includes
#include "PSSM/MDE4CPP_Extensions/PSSM_Object.hpp"
#include "PSSM/Semantics/StateMachines/StateMachinesFactory.hpp"
#include "PSSM/Semantics/StateMachines/StateMachineExecution.hpp"
#include "PSSM/Semantics/StateMachines/RegionActivation.hpp"
#include "PSSM/Semantics/StateMachines/StateActivation.hpp"
#include "PSSM/Semantics/StateMachines/FinalStateActivation.hpp"
#include "PSSM/Semantics/StateMachines/ExternalTransitionActivation.hpp"
#include "PSSM/Semantics/StateMachines/LocalTransitionActivation.hpp"
#include "PSSM/Semantics/StateMachines/InternalTransitionActivation.hpp"

#include "PSSM/Semantics/StateMachines/ForkPseudostateActivation.hpp"
#include "PSSM/Semantics/StateMachines/DeepHistoryPseudostateActivation.hpp"
#include "PSSM/Semantics/StateMachines/InitialPseudostateActivation.hpp"
#include "PSSM/Semantics/StateMachines/ExitPointPseudostateActivation.hpp"
#include "PSSM/Semantics/StateMachines/EntryPointPseudostateActivation.hpp"
#include "PSSM/Semantics/StateMachines/TerminatePseudostateActivation.hpp"
#include "PSSM/Semantics/StateMachines/JoinPseudostateActivation.hpp"
[comment]
#include "PSSM/Semantics/StateMachines/JunctionPseudostateActivation.hpp"
#include "PSSM/Semantics/StateMachines/ShallowHistoryPseudostateActivation.hpp"
#include "PSSM/Semantics/StateMachines/ChoicePseudostateActivation.hpp"

[/comment]

[/if]

[if (aPackage.getRootPackage().allOwnedElements()->filter(ActivityEdge)->reject(isDoNotGenerateElement())->size() > 0)]
//ActivityEdgeInstance include
#include "fUML/Semantics/Activities/ActivityEdgeInstance.hpp"
[/if]

//UML includes
[if (aPackage.includesFUML())]
#include "uml/Activity.hpp"
[/if]
[if (aPackage.includesPSSM())]
#include "uml/StateMachine.hpp"
#include "uml/Region.hpp"
#include "uml/State.hpp"
#include "uml/FinalState.hpp"
#include "uml/Pseudostate.hpp"
#include "uml/Transition.hpp"
[/if]
[for (anIncludeString : String | 
	aPackage.collectActivitiesOwnedByPackage()->reject(isDoNotGenerateElement()).node
	->addAll(aPackage.collectActivitiesOwnedByPackage()->reject(isDoNotGenerateElement()).node->filter(Action).input)
	->addAll(aPackage.collectActivitiesOwnedByPackage()->reject(isDoNotGenerateElement()).node->filter(Action).output)
	->addAll(aPackage.collectStructuredActivityNodesOwnedByPackage()->reject(isDoNotGenerateElement()).node)
	->addAll(aPackage.collectStructuredActivityNodesOwnedByPackage()->reject(isDoNotGenerateElement()).node->filter(Action).input)
	->addAll(aPackage.collectStructuredActivityNodesOwnedByPackage()->reject(isDoNotGenerateElement()).node->filter(Action).output)
	.generateCorrespondingActivityNodeInclude()->asSet()) before('//ActivityNode includes\n')]
[anIncludeString/]
[/for]
[for (anIncludeString : String | 
	aPackage.collectActivitiesOwnedByPackage()->reject(isDoNotGenerateElement()).edge
	->addAll(aPackage.collectStructuredActivityNodesOwnedByPackage()->reject(isDoNotGenerateElement()).edge)
	.generateCorrespondingActivityEdgeInclude()->asSet()) before('//ActivityEdge includes\n')]
[anIncludeString/]
[/for]

using namespace [aPackage.generateNamespace(false)/];

//*********************************
// Constructor / Destructor
//*********************************
[packageName/]ExecutionFactoryImpl::[packageName/]ExecutionFactoryImpl()
{
}

[packageName/]ExecutionFactoryImpl::~[packageName/]ExecutionFactoryImpl()
{
}

std::shared_ptr<fUML::Semantics::CommonBehavior::Execution> [packageName/]ExecutionFactoryImpl::createExecution(const std::shared_ptr<uml::Behavior>& behavior, const std::shared_ptr<fUML::MDE4CPP_Extensions::FUML_Object>& context)
{
[let activitiesOwnedByPackage : Set(Activity) = aPackage.collectActivitiesOwnedByPackage()->reject(isDoNotGenerateElement())->sortedBy(myQualifiedName())->asSet()]
[if (activitiesOwnedByPackage->size() > 0)]
	[for (anActivity : Activity | activitiesOwnedByPackage)  before('\tswitch(behavior->_getID())\n\t{\n') after('\t}\n')]
		case [anActivity.getNearestPackage().generateNamespace(true)/]::[anActivity.getNearestPackage().getPackageName()/]Package::[anActivity.getMemberName().toUpperCase()/]:
		{
			if(!m_[anActivity.memberName()/]ExecutionPrototype)
			{
				this->create[anActivity.memberName().toUpperFirst()/]ExecutionPrototype();
			}
			return m_[anActivity.memberName()/]ExecutionPrototype;
		}
	[/for]
[/if]
[/let]

[comment PSSM: create an Execution for a StateMachine as a ExecutionPrototype, if not already existing/]
[if (aPackage.includesPSSM())]
[let stateMachinesOwnedByPackage : Set(StateMachine) = aPackage.collectStateMachinesOwnedByPackage()->reject(isDoNotGenerateElement())->sortedBy(myQualifiedName())->asSet()]
[if (stateMachinesOwnedByPackage->size() > 0)]
	[for (aStateMachine : StateMachine | stateMachinesOwnedByPackage) before('\tswitch(behavior->_getID())\n\t{\n') after('\t}\n')]
		case [aStateMachine.getNearestPackage().generateNamespace(true)/]::[aStateMachine.getNearestPackage().getPackageName()/]Package::[aStateMachine.getMemberName().toUpperCase()/]:
		{
			if(!m_[aStateMachine.memberName()/]ExecutionPrototype)
			{
				this->create[aStateMachine.memberName().toUpperFirst()/]ExecutionPrototype(context);
			}
			return m_[aStateMachine.memberName()/]ExecutionPrototype;
		}
	[/for]
[/if]
[/let]
[/if]

	return nullptr;
}

[for (anActivity : Activity | aPackage.collectActivitiesOwnedByPackage()->reject(isDoNotGenerateElement()))]
[comment]
std::shared_ptr<fUML::Semantics::Activities::ActivityExecution> [packageName/]ExecutionFactoryImpl::get[anActivity.memberName().toUpperFirst()/]ExecutionPrototype()
{
	if(!m_[anActivity.memberName()/]ExecutionPrototype)
	{
		this->create[anActivity.memberName().toUpperFirst()/]ExecutionPrototype();
	}

	return m_[anActivity.memberName()/]ExecutionPrototype;
}
[/comment]
void [packageName/]ExecutionFactoryImpl::create[anActivity.memberName().toUpperFirst()/]ExecutionPrototype()
{
	[anActivity.generateActivityExecutionPrototypeCreatorBody()/]
}
[/for]

[comment PSSM: add functions to create ExecutionPrototypes for each StateMachine/]
[if (aPackage.includesPSSM())]
[for (aStateMachine : StateMachine | aPackage.collectStateMachinesOwnedByPackage()->reject(isDoNotGenerateElement()))]
void [packageName/]ExecutionFactoryImpl::create[aStateMachine.memberName().toUpperFirst()/]ExecutionPrototype(const std::shared_ptr<fUML::MDE4CPP_Extensions::FUML_Object>& context)
{
	[aStateMachine.generateStateMachineExecutionPrototypeCreatorBody()/]
}
[/for]
[/if]

[if (aPackage.includesPSSM())]
void [packageName/]ExecutionFactoryImpl::setThisExecutionFactoryPtr(std::weak_ptr<PSSM::Semantics::Loci::SM_ExecutionFactory> thisExecutionFactoryPtr)
{
	PSSM::Semantics::Loci::SM_ExecutionFactoryImpl::setThisExecutionFactoryPtr(thisExecutionFactoryPtr);
}
[else]
void [packageName/]ExecutionFactoryImpl::setThisExecutionFactoryPtr(std::weak_ptr</*PSCS::Semantics::Loci::CS_ExecutionFactory*/fUML::Semantics::Loci::ExecutionFactory> thisExecutionFactoryPtr)
{
	/*PSCS::Semantics::Loci::CS_ExecutionFactoryImpl::setThisExecutionFactoryPtr(thisExecutionFactoryPtr)*/ fUML::Semantics::Loci::ExecutionFactoryImpl::setThisExecutionFactoryPtr(thisExecutionFactoryPtr);
}
[/if]
[/file]
[/template]



[template private generateActivityExecutionPrototypeCreatorBody(anActivity : Activity) post(trim())
{
	activityExecutionPrototypeMemberName : String = 'm_' + anActivity.memberName() + 'ExecutionPrototype';
}]
std::shared_ptr<uml::Activity> activity = [anActivity.generatePackageGetterCall()/];
[activityExecutionPrototypeMemberName/] = fUML::Semantics::Activities::ActivitiesFactory::eInstance()->createActivityExecution();
[activityExecutionPrototypeMemberName/]->getTypes()->push_back(activity);

this->getLocus().lock()->add([activityExecutionPrototypeMemberName/]);
[activityExecutionPrototypeMemberName/]->setLocus(this->getLocus().lock());

std::shared_ptr<fUML::Semantics::Activities::ActivityNodeActivationGroup> newActivationGroup=fUML::Semantics::Activities::ActivitiesFactory::eInstance()->createActivityNodeActivationGroup_as_activationGroup_in_ActivityExecution([activityExecutionPrototypeMemberName/]);

[for (anActivityNode : ActivityNode | anActivity.node) before('//Create ActivityNodeActivations\n')]
[anActivityNode.generateActivityNodeActivationCreation()/]

[/for]
[for (anActivityEdge : ActivityEdge | anActivity.edge) before('//Create ActivityEdgeInstances\n')]
[anActivityEdge.generateActivityEdgeInstanceCreation()/]

[/for]
[/template]

[template private generateActivityNodeActivationCreation(anActivityNode : ActivityNode)  post(trim())]
//Create ActivityNodeActivation for [anActivityNode.eClass().name/] '[anActivityNode.metamodelElementName()/]'
DEBUG_INFO("Creating [anActivityNode.eClass().name/]Activation for [anActivityNode.eClass().name/] '[anActivityNode.metamodelElementName()/]'.")
std::shared_ptr<[anActivityNode.generateCorrespondingActivityNodeActivationCPPType()/]> [anActivityNode.getActivityNodeActivationVariableName()/] = [anActivityNode.generateCorrespondingFactoryNamespace()/]::eInstance()->create[anActivityNode.generateCorrespondingActivityNodeActivationClassName()/]();
[anActivityNode.getActivityNodeActivationVariableName()/]->setNode([anActivityNode.generatePackageGetterCall()/]);
[anActivityNode.getActivityNodeActivationVariableName()/]->setRunning(false);
newActivationGroup->addNodeActivation([anActivityNode.getActivityNodeActivationVariableName()/]);
[if (anActivityNode.oclIsKindOf(Action))]
[let anAction : Action = anActivityNode.oclAsType(Action)]
	[for (aPin : Pin | anAction.input->addAll(anAction.output))]
	//Create PinActivation for [aPin.eClass().name/] '[anAction.name/]::[aPin.name/]'
	std::shared_ptr<[aPin.generateCorrespondingActivityNodeActivationCPPType()/]> [aPin.getActivityNodeActivationVariableName()/] = [aPin.generateCorrespondingFactoryNamespace()/]::eInstance()->create[aPin.eClass().name/]Activation();
	[aPin.getActivityNodeActivationVariableName()/]->setNode([aPin.generatePackageGetterCall()/]);
	[aPin.getActivityNodeActivationVariableName()/]->setRunning(false);
	[anActivityNode.getActivityNodeActivationVariableName()/]->addPinActivation([aPin.getActivityNodeActivationVariableName()/]);
	newActivationGroup->addNodeActivation([aPin.getActivityNodeActivationVariableName()/]);
	[/for]
	[if(anAction.oclIsKindOf(AcceptEventAction))]
	[anActivityNode.getActivityNodeActivationVariableName()/]->setWaiting(false);
	[elseif(anAction.oclIsKindOf(StructuredActivityNode))]
	[let aStructuredActivityNode : StructuredActivityNode = anAction.oclAsType(StructuredActivityNode)]
		[for (aNestedActivityNode : ActivityNode | aStructuredActivityNode.node) before('//Create nested ActivityNodeActivations\n')]
	[aNestedActivityNode.generateActivityNodeActivationCreation()/]
		[/for]
		[for (aNestedActivityEdge : ActivityEdge | aStructuredActivityNode.edge) before('//Create nested ActivityEdgeInstances\n')]
	[aNestedActivityEdge.generateActivityEdgeInstanceCreation()/]
		[/for]
	[/let]	
	[/if]
[/let]
[/if]
[/template]

[template private generateActivityEdgeInstanceCreation(anActivityEdge : ActivityEdge)  post(trim())]
//Create ActivityEdgeInstance for [anActivityEdge.eClass().name/] '[anActivityEdge.metamodelElementName()/]'
DEBUG_INFO("Creating EdgeInstance for [anActivityEdge.eClass().name/] '[anActivityEdge.metamodelElementName()/]'.")
std::shared_ptr<[anActivityEdge.generateCorrespondingActivityEdgeInstanceCPPType()/]> [anActivityEdge.getEdgeInstanceVariableName()/] = fUML::Semantics::Activities::ActivitiesFactory::eInstance()->createActivityEdgeInstance();
[anActivityEdge.getEdgeInstanceVariableName()/]->setEdge([anActivityEdge.generatePackageGetterCall()/]);
newActivationGroup->addEdgeInstance([anActivityEdge.getEdgeInstanceVariableName()/]);
[anActivityEdge.source.getActivityNodeActivationVariableName()/]->addOutgoingEdge([anActivityEdge.getEdgeInstanceVariableName()/]);
[anActivityEdge.target.getActivityNodeActivationVariableName()/]->addIncomingEdge([anActivityEdge.getEdgeInstanceVariableName()/]);
[/template]

[comment]
The following templates return the C++ type of the corresponding ActivityNodeActivation class for a given ActivityNode
[/comment]
[comment ControlNodes /]
[template private generateCorrespondingActivityNodeActivationCPPType(anActivityNode : ActivityNode) ? (anActivityNode.oclIsKindOf(InitialNode)) post(trim())]
fUML::Semantics::Activities::InitialNodeActivation
[/template]
[template private generateCorrespondingActivityNodeActivationCPPType(anActivityNode : ActivityNode) ? (anActivityNode.oclIsKindOf(FlowFinalNode)) post(trim())]
fUML::Semantics::Activities::FlowFinalNodeActivation
[/template]
[template private generateCorrespondingActivityNodeActivationCPPType(anActivityNode : ActivityNode) ? (anActivityNode.oclIsKindOf(ActivityFinalNode)) post(trim())]
fUML::Semantics::Activities::ActivityFinalNodeActivation
[/template]
[template private generateCorrespondingActivityNodeActivationCPPType(anActivityNode : ActivityNode) ? (anActivityNode.oclIsKindOf(ForkNode)) post(trim())]
fUML::Semantics::Activities::ForkNodeActivation
[/template]
[template private generateCorrespondingActivityNodeActivationCPPType(anActivityNode : ActivityNode) ? (anActivityNode.oclIsKindOf(JoinNode)) post(trim())]
fUML::Semantics::Activities::JoinNodeActivation
[/template]
[template private generateCorrespondingActivityNodeActivationCPPType(anActivityNode : ActivityNode) ? (anActivityNode.oclIsKindOf(MergeNode)) post(trim())]
fUML::Semantics::Activities::MergeNodeActivation
[/template]
[template private generateCorrespondingActivityNodeActivationCPPType(anActivityNode : ActivityNode) ? (anActivityNode.oclIsKindOf(DecisionNode)) post(trim())]
fUML::Semantics::Activities::DecisionNodeActivation
[/template]

[comment ObjectNodes /]
[template private generateCorrespondingActivityNodeActivationCPPType(anActivityNode : ActivityNode) ? (anActivityNode.oclIsKindOf(ActivityParameterNode)) post(trim())]
fUML::Semantics::Activities::ActivityParameterNodeActivation
[/template]
[template private generateCorrespondingActivityNodeActivationCPPType(anActivityNode : ActivityNode) ? (anActivityNode.oclIsTypeOf(CentralBufferNode)) post(trim())]
fUML::Semantics::Activities::CentralBufferNodeActivation
[/template]
[template private generateCorrespondingActivityNodeActivationCPPType(anActivityNode : ActivityNode) ? (anActivityNode.oclIsTypeOf(DataStoreNode)) post(trim())]
fUML::Semantics::Activities::DataStoreNodeActivation
[/template]
[template private generateCorrespondingActivityNodeActivationCPPType(anActivityNode : ActivityNode) ? (anActivityNode.oclIsKindOf(InputPin)) post(trim())]
fUML::Semantics::Actions::InputPinActivation
[/template]
[template private generateCorrespondingActivityNodeActivationCPPType(anActivityNode : ActivityNode) ? (anActivityNode.oclIsKindOf(OutputPin)) post(trim())]
fUML::Semantics::Actions::OutputPinActivation
[/template]
[template private generateCorrespondingActivityNodeActivationCPPType(anActivityNode : ActivityNode) ? (anActivityNode.oclIsKindOf(ExpansionNode)) post(trim())]
fUML::Semantics::Actions::ExpansionNodeActivation
[/template]

[comment Actions /]
[template private generateCorrespondingActivityNodeActivationCPPType(anActivityNode : ActivityNode) ? (anActivityNode.oclIsKindOf(AcceptCallAction)) post(trim())]
[if (isPSCSExecutable())]
PSCS::Semantics::Actions::CS_AcceptCallActionActivation
[else]
fUML::Semantics::Actions::AcceptCallActionActivation
[/if]
[/template]
[template private generateCorrespondingActivityNodeActivationCPPType(anActivityNode : ActivityNode) ? (anActivityNode.oclIsKindOf(AcceptEventAction)) post(trim())]
[if (isPSCSExecutable())]
PSCS::Semantics::Actions::CS_AcceptEventActionActivation
[else]
fUML::Semantics::Actions::AcceptEventActionActivation
[/if]
[/template]
[template private generateCorrespondingActivityNodeActivationCPPType(anActivityNode : ActivityNode) ? (anActivityNode.oclIsKindOf(AddStructuralFeatureValueAction)) post(trim())]
[if (isPSCSExecutable())]
PSCS::Semantics::Actions::CS_AddStructuralFeatureValueActionActivation
[else]
fUML::Semantics::Actions::AddStructuralFeatureValueActionActivation
[/if]
[/template]
[template private generateCorrespondingActivityNodeActivationCPPType(anActivityNode : ActivityNode) ? (anActivityNode.oclIsKindOf(CallOperationAction)) post(trim())]
[if (isPSCSExecutable())]
PSCS::Semantics::Actions::CS_CallOperationActionActivation
[else]
fUML::Semantics::Actions::CallOperationActionActivation
[/if]
[/template]
[template private generateCorrespondingActivityNodeActivationCPPType(anActivityNode : ActivityNode) ? (anActivityNode.oclIsKindOf(CallBehaviorAction)) post(trim())]
fUML::Semantics::Actions::CallBehaviorActionActivation
[/template]
[template private generateCorrespondingActivityNodeActivationCPPType(anActivityNode : ActivityNode) ? (anActivityNode.oclIsKindOf(ClearStructuralFeatureAction)) post(trim())]
[if (isPSCSExecutable())]
PSCS::Semantics::Actions::CS_ClearStructuralFeatureActionActivation
[else]
fUML::Semantics::Actions::ClearStructuralFeatureActionActivation
[/if]
[/template]
[template private generateCorrespondingActivityNodeActivationCPPType(anActivityNode : ActivityNode) ? (anActivityNode.oclIsKindOf(CreateLinkAction)) post(trim())]
[if (isPSCSExecutable())]
PSCS::Semantics::Actions::CS_CreateLinkActionActivation
[else]
fUML::Semantics::Actions::CreateLinkActionActivation
[/if]
[/template]
[template private generateCorrespondingActivityNodeActivationCPPType(anActivityNode : ActivityNode) ? (anActivityNode.oclIsKindOf(CreateObjectAction)) post(trim())]
[if (isPSCSExecutable())]
PSCS::Semantics::Actions::CS_CreateObjectActionActivation
[else]
fUML::Semantics::Actions::CreateObjectActionActivation
[/if]
[/template]
[template private generateCorrespondingActivityNodeActivationCPPType(anActivityNode : ActivityNode) ? (anActivityNode.oclIsKindOf(DestroyObjectAction)) post(trim())]
fUML::Semantics::Actions::DestroyObjectActionActivation
[/template]
[template private generateCorrespondingActivityNodeActivationCPPType(anActivityNode : ActivityNode) ? (anActivityNode.oclIsKindOf(ReadExtentAction)) post(trim())]
[if (isPSCSExecutable())]
PSCS::Semantics::Actions::CS_ReadExtentActionActivation
[else]
fUML::Semantics::Actions::ReadExtentActionActivation
[/if]
[/template]
[template private generateCorrespondingActivityNodeActivationCPPType(anActivityNode : ActivityNode) ? (anActivityNode.oclIsKindOf(ReadSelfAction)) post(trim())]
[if (isPSCSExecutable())]
PSCS::Semantics::Actions::CS_ReadSelfActionActivation
[else]
fUML::Semantics::Actions::ReadSelfActionActivation
[/if]
[/template]
[template private generateCorrespondingActivityNodeActivationCPPType(anActivityNode : ActivityNode) ? (anActivityNode.oclIsKindOf(ReadStructuralFeatureAction)) post(trim())]
fUML::Semantics::Actions::ReadStructuralFeatureActionActivation
[/template]
[template private generateCorrespondingActivityNodeActivationCPPType(anActivityNode : ActivityNode) ? (anActivityNode.oclIsKindOf(RemoveStructuralFeatureValueAction)) post(trim())]
[if (isPSCSExecutable())]
PSCS::Semantics::Actions::CS_RemoveStructuralFeatureValueActionActivation
[else]
fUML::Semantics::Actions::RemoveStructuralFeatureValueActionActivation
[/if]
[/template]
[template private generateCorrespondingActivityNodeActivationCPPType(anActivityNode : ActivityNode) ? (anActivityNode.oclIsKindOf(ReplyAction)) post(trim())]
fUML::Semantics::Actions::ReplyActionActivation
[/template]
[template private generateCorrespondingActivityNodeActivationCPPType(anActivityNode : ActivityNode) ? (anActivityNode.oclIsKindOf(SendSignalAction)) post(trim())]
[if (isPSCSExecutable())]
PSCS::Semantics::Actions::CS_SendSignalActionActivation
[else]
fUML::Semantics::Actions::SendSignalActionActivation
[/if]
[/template]
[template private generateCorrespondingActivityNodeActivationCPPType(anActivityNode : ActivityNode) ? (anActivityNode.oclIsKindOf(StartClassifierBehaviorAction)) post(trim())]
fUML::Semantics::Actions::StartClassifierBehaviorActionActivation
[/template]
[template private generateCorrespondingActivityNodeActivationCPPType(anActivityNode : ActivityNode) ? (anActivityNode.oclIsKindOf(StartObjectBehaviorAction)) post(trim())]
fUML::Semantics::Actions::StartObjectBehaviorActionActivation
[/template]
[template private generateCorrespondingActivityNodeActivationCPPType(anActivityNode : ActivityNode) ? (anActivityNode.oclIsKindOf(ValueSpecificationAction)) post(trim())]
fUML::Semantics::Actions::ValueSpecificationActionActivation
[/template]

[comment Structured Activity Nodes /]
[template private generateCorrespondingActivityNodeActivationCPPType(anActivityNode : ActivityNode) ? (anActivityNode.oclIsKindOf(ExpansionRegion)) post(trim())]
fUML::Semantics::Actions::ExpansionRegionActivation
[/template]

[comment]
The following templates return the class name of the corresponding fUML/PSCS ActivityNodeActivation subclass for a given ActivityNode
[/comment]
[template private generateCorrespondingFactoryNamespace(anActivityNode : ActivityNode)
? (
	isPSCSExecutable() and
	(
		anActivityNode.oclIsTypeOf(AcceptCallAction) or
		anActivityNode.oclIsTypeOf(AcceptEventAction) or
		anActivityNode.oclIsTypeOf(AddStructuralFeatureValueAction) or
		anActivityNode.oclIsTypeOf(CallOperationAction) or
		anActivityNode.oclIsTypeOf(ClearStructuralFeatureAction) or
		anActivityNode.oclIsTypeOf(CreateLinkAction) or
		anActivityNode.oclIsTypeOf(CreateObjectAction) or
		anActivityNode.oclIsTypeOf(ReadExtentAction) or
		anActivityNode.oclIsTypeOf(ReadSelfAction) or
		anActivityNode.oclIsTypeOf(RemoveStructuralFeatureValueAction) or
		anActivityNode.oclIsTypeOf(SendSignalAction)
	)
)
post(trim())]
PSCS::Semantics::Actions::ActionsFactory
[/template]

[template private generateCorrespondingFactoryNamespace(anActivityNode : ActivityNode)
? (
	anActivityNode.oclIsKindOf(Action) or
	anActivityNode.oclIsKindOf(ExpansionNode) or
	anActivityNode.oclIsKindOf(StructuredActivityNode) or
	anActivityNode.oclIsKindOf(Pin)
)
post(trim())]
fUML::Semantics::Actions::ActionsFactory
[/template]

[comment]
The following templates return the include path of the corresponding ActivityNode as well as ActivityNodeActivation class for a given ActivityNode
[/comment]
[template private generateCorrespondingActivityNodeActivationInclude(anActivityNode : ActivityNode) post(trim())]
#include "[anActivityNode.generateCorrespondingActivityNodeActivationCPPType().substituteAll('::', '/')/].hpp"
[/template]
[template private generateCorrespondingActivityNodeInclude(anActivityNode : ActivityNode)]
#include "uml/[anActivityNode.eClass().name/].hpp"
[/template]

[comment]
The following template returns the C++ type of the corresponding ActivityEdgeInstance class for a given ActivityEdge
[/comment]
[template private generateCorrespondingActivityEdgeInstanceCPPType(anActivityEdge : ActivityEdge) post(trim())]
fUML::Semantics::Activities::ActivityEdgeInstance
[/template]

[comment]
The following templates return the include path of the corresponding ActivityEdge as well as ActivityEdgeInstance class for a given ActivityEdge
[/comment]
[template private generateCorrespondingActivityEdgeInstanceInclude(anActivityEdge : ActivityEdge) post(trim())]
#include "[anActivityEdge.generateCorrespondingActivityEdgeInstanceCPPType().substitute('::', '/')/].hpp"
[/template]
[template private generateCorrespondingActivityEdgeInclude(anActivityEdge : ActivityEdge) post(trim())]
#include "uml/[anActivityEdge.eClass().name/].hpp"
[/template]


[template private getActivityNodeActivationVariableName(anActivityNode : ActivityNode) ? (anActivityNode.oclIsKindOf(Pin)) post(trim())]
[anActivityNode.memberName()/]_[anActivityNode.eClass().name/]Activation
[/template]

[template private getActivityNodeActivationVariableName(anActivityNode : ActivityNode) post(trim())]
[anActivityNode.memberName()/]_[anActivityNode.eClass().name/]Activation
[/template]


[comment]
The following templates return the namespace name of the corresponding fUML/PSCS subpackage Factory class for a given ActivityNode
[/comment]
[comment Actions package /]
[template private generateCorrespondingActivityNodeActivationClassName(anActivityNode : ActivityNode)
? (
	isPSCSExecutable() and
	(
		anActivityNode.oclIsTypeOf(AcceptCallAction) or
		anActivityNode.oclIsTypeOf(AcceptEventAction) or
		anActivityNode.oclIsTypeOf(AddStructuralFeatureValueAction) or
		anActivityNode.oclIsTypeOf(CallOperationAction) or
		anActivityNode.oclIsTypeOf(ClearStructuralFeatureAction) or
		anActivityNode.oclIsTypeOf(CreateLinkAction) or
		anActivityNode.oclIsTypeOf(CreateObjectAction) or
		anActivityNode.oclIsTypeOf(ReadExtentAction) or
		anActivityNode.oclIsTypeOf(ReadSelfAction) or
		anActivityNode.oclIsTypeOf(RemoveStructuralFeatureValueAction) or
		anActivityNode.oclIsTypeOf(SendSignalAction)
	)
)
post(trim())]
CS_[anActivityNode.eClass().name/]Activation
[/template]

[template private generateCorrespondingActivityNodeActivationClassName(anActivityNode : ActivityNode) post(trim())]
[anActivityNode.eClass().name/]Activation
[/template]

[comment Activities package /]
[template private generateCorrespondingFactoryNamespace(anActivityNode : ActivityNode)
? (
	anActivityNode.oclIsKindOf(ActivityFinalNode) or
	anActivityNode.oclIsKindOf(ActivityParameterNode) or
	anActivityNode.oclIsKindOf(CentralBufferNode) or
	anActivityNode.oclIsKindOf(DataStoreNode) or
	anActivityNode.oclIsKindOf(DecisionNode) or
	anActivityNode.oclIsKindOf(ForkNode) or
	anActivityNode.oclIsKindOf(FlowFinalNode) or
	anActivityNode.oclIsKindOf(InitialNode) or
	anActivityNode.oclIsKindOf(JoinNode) or
	anActivityNode.oclIsKindOf(MergeNode)
)
post(trim())]
fUML::Semantics::Activities::ActivitiesFactory
[/template]

[comment]
[query private getEdgeInstanceVariableName(anActivityEdge : ActivityEdge) : String = ('from_' + anActivityEdge.source.name + '_to_' + anActivityEdge.target.name + '_EdgeInstance').sanitize() /]
[/comment]

[query private getEdgeInstanceVariableName(anActivityEdge : ActivityEdge) : String = anActivityEdge.memberName() + '_EdgeInstance' /]
