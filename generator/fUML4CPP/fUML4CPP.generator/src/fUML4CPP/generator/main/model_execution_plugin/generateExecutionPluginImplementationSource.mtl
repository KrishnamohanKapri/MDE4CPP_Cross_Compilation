[comment encoding = UTF-8 /]
[**
 * Copyright (c) 2017 TU Ilmenau, Systems and Software Engineering Group
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), 
 * to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */]
[module generateExecutionPluginImplementationSource('http://www.eclipse.org/uml2/5.0.0/UML')]

[import fUML4CPP::generator::main::helpers::parameterHelper /]
[import fUML4CPP::generator::main::helpers::fUMLCollectionHelper /]
[import fUML4CPP::generator::main::helpers::fUMLKeywords /]

[import UML4CPP::generator::main::components::generateType /]
[import UML4CPP::generator::main::helpers::generalHelper /]
[import UML4CPP::generator::main::helpers::nameHelper /]
[import UML4CPP::generator::main::helpers::keywords /]
[import UML4CPP::generator::main::model_execution::model_execution /]
[import UML4CPP::generator::main::profiles::profileHelper /]
[import UML4CPP::generator::main::profiles::uml4CPPProfileHelper /]
[import UML4CPP::generator::main::profiles::strategyHelper /]

[template public generateExecutionPluginImplSource(aPackage : Package) { packageName : String = aPackage.name.concat('ExecPluginImpl'); }]
[file (aPackage.generateNamespacePath(false).concat('Exec/impl/').concat(packageName).concat('.cpp'), false, 'UTF-8')]
#include "[aPackage.generateNamespacePath(false)/]Exec/impl/[packageName/].hpp"

[defineDebugMacro()/]

#include <iostream>
#include "abstractDataTypes/Any.hpp"
#include "abstractDataTypes/Bag.hpp"

//Includes of model-specific Locus, Executor and ExecutionFactory
#include "[aPackage.generateNamespacePath(false)/]Exec/impl/[aPackage.getPackageName()/]LocusImpl.hpp"
#include "[aPackage.generateNamespacePath(false)/]Exec/impl/[aPackage.getPackageName()/]ExecutorImpl.hpp"
#include "[aPackage.generateNamespacePath(false)/]Exec/impl/[aPackage.getPackageName()/]ExecutionFactoryImpl.hpp"

[generateMainIncludes()/]

using namespace [aPackage.generateNamespace(false)/];

//static initialization
std::shared_ptr<MDE4CPPPlugin> [aPackage.name/]ExecPlugin::eInstance()
{
	static std::shared_ptr<MDE4CPPPlugin> instance;

	if(instance==nullptr)
	{
		//create a new Singelton instance
		instance.reset(new [packageName/]());
	}
	return instance;
}

std::shared_ptr<MDE4CPPPlugin> start()
{
	return [packageName/]::eInstance();
}

//*********************************
// Constructor / Destructor
//*********************************
[packageName/]::[packageName/]()
{
	initialize();
}

[packageName/]::~[packageName/]()
{
}

std::string [packageName/]::eclipseURI()
{
	return "";
}

std::string [packageName/]::eNAME()
{
	return "[aPackage.name/]Exec";
}

std::string [packageName/]::eNS_URI()
{
	return "[aPackage.URI/]";
}

std::string [packageName/]::eNS_PREFIX()
{
	return "[if(not (aPackage.namespace.oclIsUndefined()))][aPackage.namespace.name/][/if]";
}

std::shared_ptr<ecore::EObject> [packageName/]::create(const std::string& name) const
{		
	return nullptr;
}

std::shared_ptr<ecore::EObject> [packageName/]::create(const std::string& name, std::shared_ptr<ecore::EObject> container, const unsigned int referenceID) const
{
	return nullptr;
}

void [packageName/]::initialize()
{
	[comment initialization of execution locus, factory, executor/]
	[generateExecutionPluginInitialization()/]

	m_IsInitialized = true;
}

std::shared_ptr<Any> [packageName/]::executeActivity(std::shared_ptr<uml::Activity> activity, std::shared_ptr<Bag<Any>> parameterList, std::shared_ptr<fUML::MDE4CPP_Extensions::FUML_Object> element)
{
	if(!m_IsInitialized)
	{
		initialize();
	}
[let activitiesOwnedByPackage : Set(Activity) = aPackage.collectActivitiesOwnedByPackage()->reject(isDoNotGenerateElement())->sortedBy(myQualifiedName())->asSet()]
[if (activitiesOwnedByPackage->size() > 0)]
	[for (anActivity : Activity | activitiesOwnedByPackage) before('\n\tswitch(activity->_getID())\n\t{\n') after('\t}\n')]
		case [anActivity.getNearestPackage().generateNamespace(true)/]::[anActivity.getNearestPackage().getPackageName()/]Package::[anActivity.getMemberName().toUpperCase()/]:
		{
			[anActivity.generateActivityExecution()/]
		}
	[/for]
[/if]
[/let]
	return nullptr;
}

std::shared_ptr<Bag<fUML::Semantics::CommonBehavior::ParameterValue>> [packageName/]::executeBehavior(std::shared_ptr<uml::Behavior> behavior, std::shared_ptr<fUML::MDE4CPP_Extensions::FUML_Object> context, std::shared_ptr<Bag<fUML::Semantics::CommonBehavior::ParameterValue>> inputs)
{
	if(!m_IsInitialized)
	{
		initialize();
	}

	return this->m_executor->execute(behavior, context, inputs);
}

std::shared_ptr<Any> [packageName/]::executeStateMachine(std::shared_ptr<uml::StateMachine> stateMachine, std::shared_ptr<Bag<Any>> parameterList, std::shared_ptr<fUML::MDE4CPP_Extensions::FUML_Object> element)
{
	if(!m_IsInitialized)
	{
		initialize();
	}
[let stateMachinesOwnedByPackage : Set(StateMachine) = aPackage.collectStateMachinesOwnedByPackage()->reject(isDoNotGenerateElement())->sortedBy(myQualifiedName())->asSet()]
[if (stateMachinesOwnedByPackage->size() > 0)]
	[for (aStateMachine : StateMachine | stateMachinesOwnedByPackage) before('\n\tswitch(stateMachine->_getID())\n\t{\n') after('\t}\n')]
		[comment ACHTUNG: NAMESPACE NOCH NICHT KONTROLLIERT!/]
		case [aStateMachine.getNearestPackage().generateNamespace(true)/]::[aStateMachine.getNearestPackage().getPackageName()/]Package::[aStateMachine.getMemberName().toUpperCase()/]:
		{
			[aStateMachine.generateStateMachineExecution()/]
		}
	[/for]
[/if]
[/let]
	return nullptr;
}

std::shared_ptr<fUML::MDE4CPP_Extensions::FUML_Object> [packageName/]::instantiateClass(std::shared_ptr<uml::Class> type)
{
	if(!m_IsInitialized)
	{
		initialize();
	}

	return this->m_locus->instantiate(type);
}

std::shared_ptr<fUML::MDE4CPP_Extensions::FUML_SignalInstance> [packageName/]::instantiateSignal(std::shared_ptr<uml::Signal> type)
{
	if(!m_IsInitialized)
	{
		initialize();
	}

	return this->m_locus->instantiate(type);
}

std::shared_ptr<Any> [packageName/]::evaluateSpecification(std::shared_ptr<uml::ValueSpecification> specification)
{
	return this->m_executor->evaluate(specification);
}
[/file]
[/template]

[template private generateMainIncludes(aPackage : Package)]
#include "fUML/MDE4CPP_Extensions/FUML_Object.hpp"
#include "fUML/Semantics/Actions/ActionsFactory.hpp"
#include "fUML/Semantics/Activities/ActivitiesFactory.hpp"
#include "fUML/Semantics/Activities/ActivityExecution.hpp"
#include "fUML/Semantics/Activities/ActivityNodeActivationGroup.hpp"
#include "fUML/Semantics/CommonBehavior/CommonBehaviorFactory.hpp"
#include "fUML/Semantics/CommonBehavior/ParameterValue.hpp"
#include "fUML/Semantics/Loci/LociFactory.hpp"
#include "fUML/Semantics/Loci/ExecutionFactory.hpp"
[if (isPSCSExecutable())]
#include "PSCS/MDE4CPP_Extensions/MDE4CPP_ExtensionsFactory.hpp"
#include "PSCS/Semantics/StructuredClassifiers/StructuredClassifiersFactory.hpp"
[else]
#include "fUML/Semantics/StructuredClassifiers/StructuredClassifiersFactory.hpp"
[/if]

//Semantic Strategy Includes
[aPackage.generateChoiceStrategyInclude()/]
[aPackage.generateDispatchStrategyInclude()/]
[aPackage.generateGetNextEventStrategyInclude()/]
[if (isPSCSExecutable())]
[aPackage.generateConstructStrategyInclude()/]
[aPackage.generateRequestPropagationStrategyInclude()/]
[aPackage.generateStructuralFeatureOfInterfaceAccessStrategyInclude()/]
[/if]

//UML includes
#include "uml/Element.hpp"
#include "uml/Activity.hpp"
#include "uml/Parameter.hpp"
#include "uml/UMLAny.hpp"
#include "uml/UMLContainerAny.hpp"
#include "uml/StateMachine.hpp"

//Model includes
[for (act_SM_Package : Package | 
	aPackage.collectActivitiesOwnedByPackage()->reject(isDoNotGenerateElement()).getNearestPackage()->asSet()->sortedBy(myQualifiedName())
	->union(aPackage.collectStateMachinesOwnedByPackage()->reject(isDoNotGenerateElement()).getNearestPackage()->asSet()->sortedBy(myQualifiedName()))
)]
#include "[act_SM_Package.generateNamespacePath(false)/]/[act_SM_Package.getPackageName()/]Package.hpp"
[/for]
[/template]

[template private generateConstructStrategyInclude(aPackage : Package) post(trim())]
[if (aPackage.hasCS_ConstructStrategy())]
	[let cS_ConstructStrategy : Class = aPackage.getCS_ConstructStrategy()]
#include "[cS_ConstructStrategy.getNearestPackage().generateNamespacePath(true)/]Exec/[cS_ConstructStrategy.name.toUpperFirst()/].hpp"
	[/let]
[else]
#include "PSCS/MDE4CPP_Extensions/MDE4CPP_ConstructStrategy.hpp"
[/if]
[/template]
[template private generateChoiceStrategyInclude(aPackage : Package) post(trim())]
[if (aPackage.hasChoiceStrategy())]
	[let choiceStrategy : Class = aPackage.getChoiceStrategy()]
#include "[choiceStrategy.getNearestPackage().generateNamespacePath(true)/]Exec/[choiceStrategy.name.toUpperFirst()/].hpp"
	[/let]
[else]
#include "fUML/Semantics/Loci/FirstChoiceStrategy.hpp"
[/if]
[/template]
[template private generateDispatchStrategyInclude(aPackage : Package) post(trim())]
[if (aPackage.hasDispatchStrategy())]
	[let dispatchStrategy : Class = aPackage.getDispatchStrategy()]
#include "[dispatchStrategy.getNearestPackage().generateNamespacePath(true)/]Exec/[dispatchStrategy.name.toUpperFirst()/].hpp"
	[/let]
[elseif(isPSCSExecutable())]
//#include "PSCS/Semantics/StructuredClassifiers/CS_DispatchOperationOfInterfaceStrategy.hpp"
[else]
//#include "fUML/Semantics/StructuredClassifiers/RedefinitionBasedDispatchStrategy.hpp"
[/if]
[/template]
[template private generateGetNextEventStrategyInclude(aPackage : Package) post(trim())]
[if (aPackage.hasGetNextEventStrategy())]
	[let getNextEventStrategy : Class = aPackage.getGetNextEventStrategy()]
#include "[getNextEventStrategy.getNearestPackage().generateNamespacePath(true)/]Exec/[getNextEventStrategy.name.toUpperFirst()/].hpp"
	[/let]
[else]
#include "fUML/Semantics/CommonBehavior/FIFOGetNextEventStrategy.hpp"
[/if]
[/template]
[template private generateRequestPropagationStrategyInclude(aPackage : Package) post(trim())]
[if (aPackage.hasCS_RequestPropagationStrategy())]
	[let cS_RequestPropagationStrategy : Class = aPackage.getCS_RequestPropagationStrategy()]
#include "[cS_RequestPropagationStrategy.getNearestPackage().generateNamespacePath(true)/]Exec/[cS_RequestPropagationStrategy.name.toUpperFirst()/].hpp"
	[/let]
[else]
#include "PSCS/Semantics/StructuredClassifiers/CS_DefaultRequestPropagationStrategy.hpp"
[/if]
[/template]
[template private generateStructuralFeatureOfInterfaceAccessStrategyInclude(aPackage : Package) post(trim())]
[if (aPackage.hasCS_StructuralFeatureOfInterfaceAccessStrategy())]
	[let cS_StructuralFeatureOfInterfaceAccessStrategy : Class = aPackage.getCS_StructuralFeatureOfInterfaceAccessStrategy()]
#include "[cS_StructuralFeatureOfInterfaceAccessStrategy.getNearestPackage().generateNamespacePath(true)/]Exec/[cS_StructuralFeatureOfInterfaceAccessStrategy.name.toUpperFirst()/].hpp"
	[/let]
[else]
//#include "PSCS/Semantics/StructuredClassifiers/CS_NameBased_StructuralFeatureOfInterfaceAccessStrategy.hpp"
[/if]
[/template]



[template private generateExecutionPluginInitialization(aPackage : Package) 
{locusName : String = aPackage.generateNamespace(false).sanitize() + 'Locus'; 
executorName : String = aPackage.generateNamespace(false).sanitize() + 'Executor';
executionFactoryName : String = aPackage.generateNamespace(false).sanitize() + 'ExecutionFactory';
}]
//Initialize Locus
std::shared_ptr<[locusName/]Impl> locusImpl(new [locusName/]Impl());
locusImpl->setThisLocusPtr(locusImpl);
m_locus = locusImpl;

//Initialize Executor
std::shared_ptr<[executorName/]Impl> executorImpl(new [executorName/]Impl());
executorImpl->setThisExecutorPtr(executorImpl);
m_executor = executorImpl;

m_locus->setExecutor(m_executor);
m_executor->setLocus(m_locus);

//Initialize ExecutionFactory
std::shared_ptr<[executionFactoryName/]Impl> executionFactoryImpl(new [executionFactoryName/]Impl());
executionFactoryImpl->setThisExecutionFactoryPtr(executionFactoryImpl);
m_factory = executionFactoryImpl;

m_locus->setFactory(m_factory);
m_factory->setLocus(m_locus);
[aPackage.generateChoiceStrategyAssignment()/]
[aPackage.generateDispatchStrategyAssignment()/]
[aPackage.generateGetNextEventStrategyAssignment()/]
[if (isPSCSExecutable())]
[aPackage.generateConstructStrategyAssignment()/]
[aPackage.generateRequestPropagationStrategyAssignment()/]
[aPackage.generateStructuralFeatureOfInterfaceAccessStrategyAssignment()/]
[/if]
[/template]

[template private generateStrategyAssignment(aStrategyClass : Class)]
//Assign [aStrategyClass.name.toUpperFirst()/] to execution factory
std::shared_ptr<[aStrategyClass.generateNamespaceName(true)/]> [aStrategyClass.name.toLowerFirst()/](new [aStrategyClass.generateNamespaceName(true)/]());
[aStrategyClass.name.toLowerFirst()/]->setThis[aStrategyClass.name.toUpperFirst()/]Ptr([aStrategyClass.name.toLowerFirst()/]);
m_factory->assignStrategy([aStrategyClass.name.toLowerFirst()/]);
[/template]

[template private generateConstructStrategyAssignment(aPackage : Package) post(trim())]
[if (aPackage.hasCS_ConstructStrategy())]
[aPackage.getCS_ConstructStrategy().generateStrategyAssignment()/]
[else]
//Assign CS_DefaultConstructStrategy to execution factory
m_factory->assignStrategy(PSCS::MDE4CPP_Extensions::MDE4CPP_ExtensionsFactory::eInstance()->createMDE4CPP_ConstructStrategy());
[/if]
[/template]
[template private generateChoiceStrategyAssignment(aPackage : Package) post(trim())]
[if (aPackage.hasChoiceStrategy())]
[aPackage.getChoiceStrategy().generateStrategyAssignment()/]
[else]
//Assign FirstChoiceStrategy to execution factory
m_factory->assignStrategy(fUML::Semantics::Loci::LociFactory::eInstance()->createFirstChoiceStrategy());
[/if]
[/template]
[template private generateDispatchStrategyAssignment(aPackage : Package) post(trim())]
[if (aPackage.hasDispatchStrategy())]
[aPackage.getDispatchStrategy().generateStrategyAssignment()/]
[elseif(isPSCSExecutable())]
//Assign CS_DispatchOperationOfInterfaceStrategy to execution factory
//m_factory->assignStrategy(PSCS::Semantics::StructuredClassifiers::StructuredClassifiersFactory::eInstance()->createCS_DispatchOperationOfInterfaceStrategy());
[else]
//Assign RedefinitionBasedDispatchStrategy to execution factory
//m_factory->assignStrategy(fUML::Semantics::StructuredClassifiers::StructuredClassifiersFactory::eInstance()->createRedefinitionBasedDispatchStrategy());
[/if]
[/template]
[template private generateGetNextEventStrategyAssignment(aPackage : Package) post(trim())]
[if (aPackage.hasGetNextEventStrategy())]
[aPackage.getGetNextEventStrategy().generateStrategyAssignment()/]
[else]
//Assign FIFOGetNextEventStrategy to execution factory
m_factory->assignStrategy(fUML::Semantics::CommonBehavior::CommonBehaviorFactory::eInstance()->createFIFOGetNextEventStrategy());
[/if]
[/template]
[template private generateRequestPropagationStrategyAssignment(aPackage : Package) post(trim())]
[if (aPackage.hasCS_RequestPropagationStrategy())]
[aPackage.getCS_RequestPropagationStrategy().generateStrategyAssignment()/]
[else]
//Assign CS_DefaultRequestPropagationStrategy to execution factory
m_factory->assignStrategy(PSCS::Semantics::StructuredClassifiers::StructuredClassifiersFactory::eInstance()->createCS_DefaultRequestPropagationStrategy());
[/if]
[/template]
[template private generateStructuralFeatureOfInterfaceAccessStrategyAssignment(aPackage : Package) post(trim())]
[if (aPackage.hasCS_StructuralFeatureOfInterfaceAccessStrategy())]
[aPackage.getCS_StructuralFeatureOfInterfaceAccessStrategy().generateStrategyAssignment()/]
[else]
//Assign CS_NameBased_StructuralFeatureOfInterfaceAccessStrategy to execution factory
//m_factory->assignStrategy(PSCS::Semantics::StructuredClassifiers::StructuredClassifiersFactory::eInstance()->createCS_NameBased_StructuralFeatureOfInterfaceAccessStrategy());
[/if]
[/template]

[template private generateActivityExecution(anActivity : Activity) post(trim())]
std::shared_ptr<Bag<fUML::Semantics::CommonBehavior::ParameterValue>> pList(new Bag<fUML::Semantics::CommonBehavior::ParameterValue>());
[for (aParameter : Parameter | anActivity.ownedParameter->select((direction = ParameterDirectionKind::inout) or (direction = ParameterDirectionKind::_in))) before('\n')]
//Creating ParameterValue for input parameter [anActivity.name/]::[aParameter.name/]
{
	const std::shared_ptr<Any>& [aParameter.name/] = parameterList->at([aParameter.listNumber(anActivity)/]);
	std::shared_ptr<fUML::Semantics::CommonBehavior::ParameterValue> [aParameter.name/]_parameterValue = fUML::Semantics::CommonBehavior::CommonBehaviorFactory::eInstance()->createParameterValue();
	[aParameter.name/]_parameterValue->setParameter([aParameter.generatePackageGetterCall()/]);
[comment Anys that contain a list of elements has to be expanded /]
[if (aParameter.upper <> 1)]
	[if (aParameter.type.oclIsKindOf(PrimitiveType) or aParameter.type.oclIsKindOf(Enumeration))]
	[aParameter.generateCppType(false)/] elementList = [aParameter.name/]->get<[aParameter.generateCppType(false)/]>();
	for(const [aParameter.type.generateCppRawType(false)/]& anElement : *elementList)
	{
		[aParameter.name/]_parameterValue->getValues()->add(eAny(anElement, [aParameter.name/]->getTypeId(), false));
	}
	[else]
	const std::shared_ptr<uml::UMLContainerAny>& umlContainerAny = std::dynamic_pointer_cast<uml::UMLContainerAny>([aParameter.name/]);
	const std::shared_ptr<Bag<uml::Element>>& elementList = umlContainerAny->getAsElementContainer();
	for(const std::shared_ptr<uml::Element>& anElement : *elementList)
	{
		[aParameter.name/]_parameterValue->getValues()->add(eUMLAny(anElement, [aParameter.name/]->getTypeId()));
	}
	[/if]
[else]
	[aParameter.name/]_parameterValue->getValues()->add([aParameter.name/]);
[/if]
	pList->add([aParameter.name/]_parameterValue);
}
[/for]

//Executing Activity [anActivity.name/]
const std::shared_ptr<Bag<fUML::Semantics::CommonBehavior::ParameterValue>>& outputParameterValues = m_locus->getExecutor()->execute([anActivity.generatePackageGetterCall()/], element, pList);

[if (anActivity.ownedParameter->select(p :Parameter | p.direction = ParameterDirectionKind::return)->notEmpty())]
//The activity has a return parameter
[let par : Parameter = anActivity.ownedParameter->select(p :Parameter | p.direction = ParameterDirectionKind::return)->first()]
std::shared_ptr<Any> returnValue;
const std::shared_ptr<uml::Parameter>& returnParameter = [par.generatePackageGetterCall()/];

for(const std::shared_ptr<fUML::Semantics::CommonBehavior::ParameterValue>& parameterValue : *outputParameterValues)
{
	if(returnParameter == parameterValue->getParameter())
	{
	[if (par.upper <> 1)]
		const std::shared_ptr<Bag<Any>>& anyList = parameterValue->getValues();
		[if (par.type.oclIsKindOf(PrimitiveType) or par.type.oclIsKindOf(Enumeration))]
		[par.generateCppType(false)/] elementList(new Bag<[par.type.generateCppRawType(true)/]>());
		[else]
		std::shared_ptr<Bag<uml::Element>> elementList(new Bag<uml::Element>());
		[/if]
		for(const std::shared_ptr<Any>& any : *anyList)
		{
		[if (par.type.oclIsKindOf(PrimitiveType) or par.type.oclIsKindOf(Enumeration))]
			[par.type.generateCppRawType(true)/] element = any->get<[par.type.generateCppRawType(true)/]>();
			elementList->add(element);
		[else]
			std::shared_ptr<uml::Element> element = retrieveAnyValueAsUMLElement(any);
			elementList->add(element);
		[/if]
		}
		[if (par.type.oclIsKindOf(PrimitiveType) or par.type.oclIsKindOf(Enumeration))]
		returnValue = eAny(elementList, -1 /*ID for primitive types??*/, true);
		[else]
		returnValue = eUMLContainerAny(elementList, [par.type.getNearestPackage().generateNamespace(true)/]::[par.type.getNearestPackage().getPackageName()/]Package::[par.type.oclAsType(Classifier).getMemberName().toUpperCase()/]);
		[/if]
	[else]
		returnValue = parameterValue->getValues()->at(0);
	[/if]
		break;
	}
}

return returnValue;
[/let]
[else]
DEBUG_INFO("Activity [anActivity.myQualifiedName()/] does not have any return parameter.")
return nullptr;
[/if]
[/template]

[template private generateStateMachineExecution(aStateMachine : StateMachine) post(trim())]
[comment]
std::shared_ptr<Bag<fUML::Semantics::CommonBehavior::ParameterValue>> pList(new Bag<fUML::Semantics::CommonBehavior::ParameterValue>());
[for (aParameter : Parameter | aStateMachine.ownedParameter->select((direction = ParameterDirectionKind::inout) or (direction = ParameterDirectionKind::_in))) before('\n')]
//Creating ParameterValue for input parameter [aStateMachine.name/]::[aParameter.name/]
{
	const std::shared_ptr<Any>& [aParameter.name/] = parameterList->at([aParameter.listNumber(aStateMachine)/]);
	std::shared_ptr<fUML::Semantics::CommonBehavior::ParameterValue> [aParameter.name/]_parameterValue = fUML::Semantics::CommonBehavior::CommonBehaviorFactory::eInstance()->createParameterValue();
	[aParameter.name/]_parameterValue->setParameter([aParameter.generatePackageGetterCall()/]);
comment Anys that contain a list of elements has to be expanded
[if (aParameter.upper <> 1)]
	[if (aParameter.type.oclIsKindOf(PrimitiveType) or aParameter.type.oclIsKindOf(Enumeration))]
	[aParameter.generateCppType(false)/] elementList = [aParameter.name/]->get<[aParameter.generateCppType(false)/]>();
	for(const [aParameter.type.generateCppRawType(false)/]& anElement : *elementList)
	{
		[aParameter.name/]_parameterValue->getValues()->add(eAny(anElement, [aParameter.name/]->getTypeId(), false));
	}
	[else]
	const std::shared_ptr<uml::UMLContainerAny>& umlContainerAny = std::dynamic_pointer_cast<uml::UMLContainerAny>([aParameter.name/]);
	const std::shared_ptr<Bag<uml::Element>>& elementList = umlContainerAny->getAsElementContainer();
	for(const std::shared_ptr<uml::Element>& anElement : *elementList)
	{
		[aParameter.name/]_parameterValue->getValues()->add(eUMLAny(anElement, [aParameter.name/]->getTypeId()));
	}
	[/if]
[else]
	[aParameter.name/]_parameterValue->getValues()->add([aParameter.name/]);
[/if]
	pList->add([aParameter.name/]_parameterValue);
}
[/for]
[/comment]

//Executing StateMachine [aStateMachine.name/]
const std::shared_ptr<Bag<fUML::Semantics::CommonBehavior::ParameterValue>>& outputParameterValues = m_locus->getExecutor()->execute([aStateMachine.generatePackageGetterCall()/], [if (aStateMachine.owner.oclIsKindOf(Class))]element[else]nullptr[/if], nullptr);

[comment]]
[if (aStateMachine.ownedParameter->select(p :Parameter | p.direction = ParameterDirectionKind::return)->notEmpty())]
//The State Machine has a return parameter
[let par : Parameter = aStateMachine.ownedParameter->select(p :Parameter | p.direction = ParameterDirectionKind::return)->first()]
std::shared_ptr<Any> returnValue;
const std::shared_ptr<uml::Parameter>& returnParameter = [par.generatePackageGetterCall()/];

for(const std::shared_ptr<fUML::Semantics::CommonBehavior::ParameterValue>& parameterValue : *outputParameterValues)
{
	if(returnParameter == parameterValue->getParameter())
	{
		returnValue = parameterValue->getValues()->at(0);
		break;
	}
}

return returnValue;
[/let]
[else]
DEBUG_INFO("StateMachine [aStateMachine.myQualifiedName()/] does not have any return parameter.")
[/comment]
return nullptr;
[comment]
[/if]
[/comment]
[/template]

[template private generateExecutionPluginDeinitialization(aPackage : Package)]
//uninitialize execution factory
m_factory->getPrimitiveBehaviorPrototypes()->clear();
m_factory->setLocus(nullptr);

//uninitialize executor
m_executor->setLocus(nullptr);

//uninitialize execution locus
m_locus->setExecutor(nullptr);
m_locus->setFactory(nullptr);
[/template]

[query public listNumber(aParameter : Parameter, anActivity : Activity) : Integer =  
	anActivity.ownedParameter->select((direction = ParameterDirectionKind::_out) or (direction = ParameterDirectionKind::_in))->indexOf(aParameter)-1 /]

[query private rejectClassOperationWithoutMethod(anOperation : Operation) : Boolean = (not owner.oclIsKindOf(Interface)) and (method->isEmpty()) and (not isAbstract)/]