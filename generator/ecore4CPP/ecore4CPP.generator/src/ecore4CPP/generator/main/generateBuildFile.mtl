[comment encoding = UTF-8 /]
[**
 * Copyright (c) 2017 TU Ilmenau, Systems and Software Engineering Group
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), 
 * to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */]
[module generateBuildFile('http://www.eclipse.org/emf/2002/Ecore')]

[import ecore4CPP::generator::main::helper /]
[import ecore4CPP::generator::main::helpers::keywords /]
[import ecore4CPP::generator::main::validation::validation /]

[query public metaModelLibraries(anEPackage : EPackage) : Set(EPackage) = OrderedSet{anEPackage.eAllContents().eClass().getRootPackage(),anEPackage.eAllContents(EClass).eAllSuperTypes.getRootPackage(),anEPackage.eAllContents(EStructuralFeature).eType.getRootPackage(),anEPackage.eAllContents(EParameter).eType.getRootPackage()}->flatten()->sortedBy(name) /]

[template public generateBuildFile(aPackage : EPackage) { packageSrcPath : String = aPackage.generateNamespacePath(); packageName : String = aPackage.generatePackageName();  }]

[comment ------------------------------------------------------------------- /]
[comment generate CMakeLists.txt for model libary                            /]
[comment ------------------------------------------------------------------- /]
[file (packageName.concat('/').concat('CMakeLists.txt'), false, 'UTF-8')]
# DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN
# @generator: ecore4cpp::generator::main::generateBuildFile

# C++ project of model [packageName/].ecore, generated by Ecore4CPP

CMAKE_MINIMUM_REQUIRED(VERSION 3.9)

PROJECT([packageName/])

IF(NOT CMAKE_BUILD_TYPE) 
    SET(CMAKE_BUILD_TYPE Debug)
ENDIF(NOT CMAKE_BUILD_TYPE)
SET(CMAKE_DEBUG_POSTFIX d)

SET(CMAKE_CXX_STANDARD 17)

IF(("$ENV{DEBUG_MESSAGE_[packageName.toUpper()/]}" EQUAL "1") AND (CMAKE_BUILD_TYPE MATCHES Debug))
	SET(ENABLED_DEBUG_MESSAGE " ")
ELSE()
	SET(ENABLED_DEBUG_MESSAGE " -DNDEBUG")
ENDIF()
IF("$ENV{DEBUG_MESSAGE_ACTIVITY_DEBUGGER}" EQUAL "1")
	SET(ENABLED_DEBUG_MESSAGE "${ENABLED_DEBUG_MESSAGE} -DACTIVITY_DEBUG_ON")
ENDIF()

[comment IF("${CMAKE_CXX_COMPILER_ID}" STREQUAL "AppleClang") -> not necessary after removing openmp/]
SET(CMAKE_CXX_FLAGS "-Wall -Wno-narrowing -Wno-overloaded-virtual -Wdeprecated-declarations -fmax-errors=5")
IF(APPLE)
  string(APPEND CMAKE_CXX_FLAGS " -Qunused-arguments")
ENDIF(APPLE)
SET(CMAKE_CXX_FLAGS_DEBUG " -Og -ggdb ${ENABLED_DEBUG_MESSAGE}")
SET(CMAKE_CXX_FLAGS_RELEASE " -O3  ${ENABLED_DEBUG_MESSAGE}")

string(REPLACE "\\" "/" MDE4CPP_HOME $ENV{MDE4CPP_HOME})

SET(SOURCE_FILES
# Factories and packages
	[aPackage.generatePackageAndFactory()/]
[if hasCreateApiFlag()]
# REST-Api
	[aPackage.generateAPI()/]
[/if]
# Package plugin
	impl/[packageName/]PluginImpl.cpp
# Package content
[for (aClass : EClass | aPackage.eAllContents(EClass)->reject(doNotGenerateEClassifier())->asOrderedSet()->sortedBy(name))]
	[aClass.getNamespacePathWithoutRoot()/]impl/[aClass.name.toUpperFirst()/]Impl.cpp
[/for]
[if (packageName='uml')]
	${MDE4CPP_HOME}/application/include/util/util.cpp
	${MDE4CPP_HOME}/application/include/util/registry.cpp
	${MDE4CPP_HOME}/application/include/util/stereotypestorage.cpp
[/if]
	#${MDE4CPP_HOME}/application/include/util/ProfileCallCount.cpp
)

INCLUDE_DIRECTORIES(
	../
	${MDE4CPP_HOME}/application/include
)

# Apple specific stuff
if(APPLE)
  set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -undefined dynamic_lookup")
  set(CMAKE_MODULE_LINKER_FLAGS "${CMAKE_MODULE_LINKER_FLAGS} -undefined dynamic_lookup")
endif(APPLE)

IF(CMAKE_SYSTEM_NAME STREQUAL "Windows" OR (NOT CMAKE_SYSTEM_NAME AND WIN32))
    # Windows (native or cross-compiled)
	[generateCMakeFindLibraryCommands('', 'lib')/]
ELSEIF(APPLE)
	[generateCMakeFindLibraryCommands('.dylib', 'bin')/]
ELSEIF(UNIX)
    # Linux, BSD, Solaris, Minix
	[generateCMakeFindLibraryCommands('.so', 'bin')/]
ELSE()
	[generateCMakeFindLibraryCommands('', 'lib')/]
ENDIF()

ADD_LIBRARY(${PROJECT_NAME} SHARED ${SOURCE_FILES})

ADD_DEFINITIONS(-DBUILD_[aPackage.getRootPackage().name.toUpper()/]=1)

SET_TARGET_PROPERTIES(${PROJECT_NAME} PROPERTIES PREFIX "")

# Export all symbols for Windows DLLs (needed for cross-compilation)
# This ensures virtual functions from base classes are visible when linking
IF(CMAKE_SYSTEM_NAME STREQUAL "Windows" OR (NOT CMAKE_SYSTEM_NAME AND WIN32))
    SET_TARGET_PROPERTIES(${PROJECT_NAME} PROPERTIES WINDOWS_EXPORT_ALL_SYMBOLS TRUE)
ENDIF()

IF (CMAKE_BUILD_TYPE STREQUAL "Debug")
	[generateLibraryLinking(true)/]
ELSE()
	[generateLibraryLinking(false)/]
ENDIF()

#-----------------------------------------------------
# DELIVERING binaries and header to ${MDE4CPP_HOME}
#-----------------------------------------------------

INSTALL(TARGETS ${PROJECT_NAME}
	RUNTIME DESTINATION ${MDE4CPP_HOME}/application/bin
    LIBRARY DESTINATION ${MDE4CPP_HOME}/application/bin
    ARCHIVE DESTINATION ${MDE4CPP_HOME}/application/lib
)

INSTALL(DIRECTORY . DESTINATION ${MDE4CPP_HOME}/application/include/${PROJECT_NAME}
	FILES_MATCHING PATTERN "*.hpp"
	PATTERN ".cmake" EXCLUDE
)
[/file]

[comment ------------------------------------------------------------------- /]
[comment gradle file for build command                                       /]
[comment ------------------------------------------------------------------- /]
[file ('../build.gradle', false, 'UTF-8')]
// DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN
// @generator: ecore4cpp::generator::main::generateBuildFile
plugins{
	id "tui.sse.mde4cpp.MDE4CPPGenerate" version "0.6"	
}

import org.gradle.internal.os.OperatingSystem;

description 'Build task for project: [packageName/]'

[comment Ensure OperatingSystem is available in doFirst /]

task runCommandCompile[packageName.toUpperFirst()/](type:Exec) {[comment internal task --> no group --> no visualisation in gradle tasks/]
	workingDir project.projectDir
	def rootPath = project.rootDir.toPath()
	def projectPath = project.projectDir.toPath()
	def relativeToRoot = rootPath.relativize(projectPath)
	def depth = relativeToRoot.nameCount
	def gradlewRelPath = '../' * depth + 'application/tools/gradlew'
	if (OperatingSystem.current().isWindows()) {
		def gradlewPathWin = gradlewRelPath.replace('/', '\\')
		commandLine 'cmd', '/c', gradlewPathWin + '.bat src_gen:compile[packageName.toUpperFirst()/]Src'
	} else {
		commandLine '/bin/sh', '-c', gradlewRelPath + ' src_gen:compile[packageName.toUpperFirst()/]Src'
	}
	dependsOn 'generate[packageName.toUpperFirst()/]'
[if (aPackage.name = 'ecore')]
	[comment Ensure abstractDataTypes headers are available before compiling ecore /]
	dependsOn ':src:deliverBasicInterfaces'
[/if]
[for (pack : EPackage | aPackage.metaModelLibraries()->reject(doNotGenerateEPackage())) ? (not(pack.name = aPackage.name))]
	[comment Use task path directly for more reliable dependency resolution /]
	[comment Handle special cases: types package is always under uml, fUML/PSCS use lowercase directory names /]
	[if (pack.name = 'types')]
	dependsOn ':src:uml:types:buildTypes'
	[else]
		[if (pack.name = 'fUML')]
	dependsOn ':src:fuml:buildFUML'
		[else]
			[if (pack.name = 'PSCS')]
	dependsOn ':src:pscs:buildPSCS'
			[else]
				[comment Use generateNamespacePath to get full path, or pack.name for root packages /]
				[if (pack.generateNamespacePath() = '' or pack.generateNamespacePath() = '/')]
	dependsOn ':src:[pack.name/]:build[pack.name.toUpperFirst()/]'
				[else]
	dependsOn ':src:[pack.generateNamespacePath()/]:build[pack.name.toUpperFirst()/]'
				[/if]
			[/if]
		[/if]
	[/if]
[/for]
	[aPackage.generateInputsFilesForRunCommand()/]
	[aPackage.generateMustRunAfter()/]
	doFirst {
		[comment Ensure dependency library files exist before executing inner gradlew command /]
		def mde4cppHome = System.getenv('MDE4CPP_HOME')
		if (mde4cppHome && OperatingSystem.current().isLinux()) {
[for (pack : EPackage | aPackage.metaModelLibraries()->reject(doNotGenerateEPackage())) ? (not(pack.name = aPackage.name))]
			def [pack.name/]LibFile = new File(mde4cppHome, 'application/bin/[pack.name/].so')
			if (![pack.name/]LibFile.exists()) {
				[comment Wait and retry to handle race conditions /]
				sleep(2000)
				if (![pack.name/]LibFile.exists()) {
					[comment Construct task path for error message /]
					[if (pack.name = 'types')]
					def taskPath = ':src:uml:types:buildTypes'
					[else]
						[if (pack.name = 'fUML')]
					def taskPath = ':src:fuml:buildFUML'
						[else]
							[if (pack.name = 'PSCS')]
					def taskPath = ':src:pscs:buildPSCS'
							[else]
								[if (pack.generateNamespacePath() = '' or pack.generateNamespacePath() = '/')]
					def taskPath = ':src:[pack.name/]:build[pack.name.toUpperFirst()/]'
								[else]
					def taskPath = ':src:[pack.generateNamespacePath()/]:build[pack.name.toUpperFirst()/]'
								[/if]
							[/if]
						[/if]
					[/if]
					throw new GradleException("Dependency library file does not exist: " + [pack.name/]LibFile.absolutePath + ". Task " + taskPath + " must complete first.")
				}
			}
[/for]
		}
	}
}

task runCommandGenerate[packageName.toUpperFirst()/](type: tui.sse.mde4cpp.MDE4CPPGenerate) {
	def modelPath = file('.' + File.separator + 'model' + File.separator + '[packageName/].ecore')
	modelFilePath = modelPath.absolutePath
}

[if (aPackage.prepareApplication())]
task runCommandCompileApplicationFor[packageName.toUpperFirst()/](type:Exec) {
	workingDir project.projectDir
	def rootPath = project.rootDir.toPath()
	def projectPath = project.projectDir.toPath()
	def relativeToRoot = rootPath.relativize(projectPath)
	def depth = relativeToRoot.nameCount
	def gradlewRelPath = '../' * depth + 'application/tools/gradlew'
	if (OperatingSystem.current().isWindows()) {
		def gradlewPathWin = gradlewRelPath.replace('/', '\\')
		commandLine 'cmd', '/c', gradlewPathWin + '.bat application:compileApplicationFor[packageName.toUpperFirst()/]Src'
	} else {
		commandLine '/bin/sh', '-c', gradlewRelPath + ' application:compileApplicationFor[packageName.toUpperFirst()/]Src'
	}
	dependsOn 'compile[packageName.toUpperFirst()/]'
}
[/if]

task generate[packageName.toUpperFirst()/]() {
	group '[packageName/]'	
	description 'generate C++ code of [packageName/].ecore model [packageName/]' 
 
	def buildFile = file('model'+ File.separator +'build.gradle')
	if(!buildFile.exists())
	{
		dependsOn 'runCommandGenerate[packageName.toUpperFirst()/]'
	}
	else
	{
		dependsOn 'model:generate[packageName.toUpperFirst()/]Model'
	}
}

task compile[packageName.toUpperFirst()/]() {
	group '[packageName/]'
	description 'compile [packageName/]' 

	[comment Always ensure generation runs first /]
	dependsOn 'generate[packageName.toUpperFirst()/]'
	mustRunAfter = ['['/]"generate[packageName.toUpperFirst()/]"[']'/]
[if (aPackage.name = 'ecore')]
	[comment Ensure abstractDataTypes headers are available before compiling ecore /]
	dependsOn ':src:deliverBasicInterfaces'
[/if]
	
	[comment Check if src_gen/build.gradle exists - if not, use runCommandCompile which will work after generation /]
	def buildFile = file('src_gen'+ File.separator + 'build.gradle')
	
	if(buildFile.exists()) {
		[comment Use direct dependency if src_gen/build.gradle exists /]
		dependsOn 'src_gen:compile[packageName.toUpperFirst()/]Src'
	} else {
		[comment Use runCommandCompile if src_gen doesn't exist yet - generation will create it first /]
		dependsOn 'runCommandCompile[packageName.toUpperFirst()/]'
	}
	
	[aPackage.generateMustRunAfter()/]
}

[if(aPackage.prepareApplication())]
task compileApplicationFor[packageName.toUpperFirst()/]{
	group '[packageName/]'
	description 'compile ['ApplicationFor'.concat(packageName)/]'

	dependsOn 'runCommandCompileApplicationFor[packageName.toUpperFirst()/]'
	dependsOn 'compile[packageName.toUpperFirst()/]'
	mustRunAfter = ['['/]"compile[packageName.toUpperFirst()/]"[']'/]
}
[/if]

task build[packageName.toUpperFirst()/]() {
	group '[packageName/]'
	description 'build [packageName/]'

	dependsOn 'generate[packageName.toUpperFirst()/]'
	dependsOn 'compile[packageName.toUpperFirst()/]'
[if (aPackage.name = 'ecore')]
	[comment Ensure abstractDataTypes headers are available before building ecore /]
	dependsOn ':src:deliverBasicInterfaces'
[/if]
[if(aPackage.prepareApplication())]
	dependsOn 'compileApplicationFor[packageName.toUpperFirst()/]'
[/if]
[if hasCreateApiFlag()]
	dependsOn getRootProject().getTasksByName('deliverBoostLibray', true)
[/if]
[for (pack : EPackage | aPackage.metaModelLibraries()->reject(doNotGenerateEPackage())) before ('\n') ? (not(pack.name = aPackage.name))]
	dependsOn getRootProject().getTasksByName('build[pack.name.toUpperFirst()/]', true)
[/for]
[for (libName : String | aPackage.eAllContents()->filter(EClass)->reject(doNotGenerateEClassifier())->select(c : EClass | c.hasKey(keyLibrary())).valueKeys(keyLibrary())->asOrderedSet())]
[if (not (libName.oclIsUndefined() or libName = ''))]
	dependsOn getRootProject().getTasksByName('build[libName.toUpperFirst()/]', true)
[/if]
[/for]
}
[if hasCreateApiFlag()]
tasks.getByPath('src_gen:compile[packageName.toUpperFirst()/]').mustRunAfter getRootProject().getTasksByName('deliverBoostLibray',true)
[/if]
[/file]

[comment ------------------------------------------------------------------- /]
[comment gradle file for generate command                                    /]
[comment ------------------------------------------------------------------- /]
[file ('../model/build.gradle', false, 'UTF-8')]
// DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN
// @generator: ecore4cpp::generator::main::generateBuildFile
plugins{
	id "tui.sse.mde4cpp.MDE4CPPGenerate" version "0.6"	
}

description 'Generate task for project: [packageName/]'

task generate[packageName.toUpperFirst()/]Model(type: tui.sse.mde4cpp.MDE4CPPGenerate) {
[comment group '[packageName ?' invisible internal generate tasks/]
	description 'generate C++ code of [packageName/].ecore model'

	modelFilePath = file('.' + File.separator + '[packageName/].ecore')
	relatedModels = ['['/][aPackage.generateRelatedModelNameList()/][']'/]	
	outputs.files(fileTree('../src_gen/[packageName/]') {
        exclude '.cmake/**'
    })
	
	[comment dependency is used to enshure that a generator is existing and updated. But /]	
	[comment getTasksByName is used because it throws no exception. This dependecy is only useful for root tasks /]  
	def dependencyTask = getRootProject().getTasksByName('deliverEcore4CPP',true)
	if (dependencyTask)
	{
		dependsOn dependencyTask
	}
	[comment To Debug Dependencies 
	else
	{
		println "local build: Please make sure that ecore4CPP has been created correctly."
	}
	/]
	[comment used from main, but fails local dependsOn rootProject.tasks.getByPath(':generator:ecore4CPP:ecore4CPP.generator:deliverEcore4CPP')/]
	[comment dependsOn rootProject.tasks.getByPath(':generator:ecore4CPP:buildGenerator_ecore4CPP') /]
}
[/file]

[comment ------------------------------------------------------------------- /]
[comment gradle file for compile command of model                            /]
[comment ------------------------------------------------------------------- /]
[file ('build.gradle', false, 'UTF-8')]
// DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN
// @generator: ecore4cpp::generator::main::generateBuildFile
plugins{
	id "tui.sse.mde4cpp.MDE4CPPCompile" version "0.6"	
}

import org.gradle.internal.os.OperatingSystem;

description 'Compile task for project: [packageName/]'

task compile[packageName.toUpperFirst()/]Src(type: tui.sse.mde4cpp.MDE4CPPCompile) {
[comment group '[packageName?' invisible internal compile tasks /]
	description 'compile [packageName/]'

	projectFolder = file('.' + File.separator + '[packageName/]')

	inputs.files(fileTree('.') {
        exclude '[packageName/]/.cmake/**'
    })

   	if(!file(['['/]'[packageName/]','.cmake'[']'/].join(File.separator)).exists()){
   	    outputs.upToDateWhen { false }
   	}

	if(OperatingSystem.current().isWindows()){
		if(project.hasProperty('RELEASE') && !project.property('RELEASE').equals('0')){outputs.file file(['['/]rootDir,'application','bin','[packageName/]' +       '.dll'[']'/].join(File.separator))}
		if(project.hasProperty('DEBUG') && !project.property('DEBUG').equals('0'))  {outputs.file file(['['/]rootDir,'application','bin','[packageName/]' + 'd' + '.dll'[']'/].join(File.separator))}
	}
	else if(OperatingSystem.current().isLinux()){
		if(project.hasProperty('RELEASE') && !project.property('RELEASE').equals('0')){outputs.file file(['['/]rootDir,'application','bin','[packageName/]' +       '.so'[']'/].join(File.separator))}
		if(project.hasProperty('DEBUG') && !project.property('DEBUG').equals('0'))  {outputs.file file(['['/]rootDir,'application','bin','[packageName/]' + 'd' + '.so'[']'/].join(File.separator))}
	}
	else if(OperatingSystem.current().isMacOsX()){
		if(project.hasProperty('RELEASE') && !project.property('RELEASE').equals('0')){outputs.file file(['['/]rootDir,'application','bin','[packageName/]' +       '.dylib'[']'/].join(File.separator))}
		if(project.hasProperty('DEBUG') && !project.property('DEBUG').equals('0'))  {outputs.file file(['['/]rootDir,'application','bin','[packageName/]' + 'd' + '.dylib'[']'/].join(File.separator))}
	}
	else {
	    //not supported os
	}

	outputs.files(fileTree(['['/]rootDir,'application','include','[packageName/]'[']'/].join(File.separator)))
	outputs.dir(['['/]rootDir,'application','include','[packageName/]'[']'/].join(File.separator))

	def buildFile = file('..'+File.separator+'model'+File.separator+'build.gradle')
	if(!buildFile.exists()) [comment In case of model build file was deleted /]
	{
		dependsOn getRootProject().getTasksByName('runCommandGenerate[packageName.toUpperFirst()/]', true)
		mustRunAfter = ['['/]getRootProject().getTasksByName('runCommandGenerate[packageName.toUpperFirst()/]', true)[']'/]
	}
	else
	{
		[comment wenn dies einkommentiert wird, wird bei jeder QuellcodÃ¤nderung compiliert! dependsOn  getRootProject().getTasksByName('generate[packageName.toUpperFirst()/? Model', true) /]
		mustRunAfter = ['['/]getRootProject().getTasksByName('generate[packageName.toUpperFirst()/]Model', true)[']'/]
	}	
	[comment
	// dependency to 'persistence'
	//def persistence = getRootProject().getTasksByName('compilePersistence', true)
	//dependsOn persistence
	//inputs.files(persistence.outputs)

	// dependency to 'pluginFramwork'
	//def pluginFramwork = getRootProject().getTasksByName('compilePluginFramework', true)
	//dependsOn pluginFramwork
	//inputs.files(pluginFramwork.outputs)
	/]

	[comment
		Dependency to basic interface HEADERS
		- deliverAbstractDataTypes 
    	- deliverPluginFrameworkInterface
    	- deliverPersistenceInterface
    	- deliverUtil
	/]
	dependsOn getRootProject().getTasksByName('deliverBasicInterfaces', true)

[for (pack : EPackage | aPackage.metaModelLibraries()->sortedBy(name)->reject(doNotGenerateEPackage())) ? (not(pack.name = aPackage.name))]

	// dependency to model '[pack.name/]'
	def [pack.name/] = getRootProject().getTasksByName('compile[pack.name.toUpperFirst()/]Src', true)
	if([pack.name/].isEmpty())  [comment if src_gen folder was deleted --> no compileTasks --> no dependency/]
	{
		logger.info('Task not found: ' + [pack.name/].toString() + '. Use build[pack.name.toUpperFirst()/] now')
		def build[pack.name/] = getRootProject().getTasksByName('build[pack.name.toUpperFirst()/]', true)
		dependsOn build[pack.name/]
		inputs.files(build[pack.name/].outputs)
	}
	else
	{
		dependsOn [pack.name/]
		inputs.files([pack.name/].outputs)
	}
[/for]
[let dependendPackages : OrderedSet(EClass) = aPackage.eAllContents()->filter(EClass)->reject(doNotGenerateEClassifier())->select(c : EClass | c.hasKey(keyLibrary())).valueKeys(keyLibrary())->asOrderedSet()]
	[if(dependendPackages->size()>0)]
		[for (libName : String | dependendPackages)]
			[if (not (libName.oclIsUndefined() or libName = ''))]
	// dependency to model '[libName/]'
	def [libName/] = getRootProject().getTasksByName('compile[libName.toUpperFirst()/]Src', true)
	dependsOn [libName/]
	inputs.files([libName/].outputs)
			[/if]
		[/for]
	mustRunAfter = ['['/]
		[for (libName : String | dependendPackages) separator (', ')]
		[if (not (libName.oclIsUndefined() or libName = ''))] [libName/]
		[/if][libName/]
		[/for][']'/]
	[/if]
[/let]
}

task clean {
	// Extension of gradle built-in task:clean
	doLast {
		def dot_cmake = file('[packageName/]/.cmake')
		if(dot_cmake.exists()){
			delete dot_cmake.absolutePath
			println "deleting: " + dot_cmake.absolutePath
		}
		
		compile[packageName.toUpperFirst()/]Src.outputs.files.each{
			if(it.exists()){
				delete it.absolutePath
			    println "deleting: " + it
			}
  		}
	}
}
[/file]
[aPackage.generateSettingsGradleFile()/]
[/template]



[comment ------------------------------------------------------------------- /]
[comment generate settings.gradle file                                       /]
[comment ------------------------------------------------------------------- /]

[template private generateSettingsGradleFile(aPackage : EPackage) { packageName : String = aPackage.generatePackageName(); }]
[file ('../settings.gradle', false, 'UTF-8')]
// DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN
// @generator: ecore4cpp::generator::main::generateBuildFile

pluginManagement {
	repositories {
		mavenLocal()
[comment 		mavenCentral()
		gradlePluginPortal() /]
	}
}

rootProject.name = '[packageName/]'

include ':model'
include ':src_gen'
[if (aPackage.prepareApplication())]
include ':application'
[/if]

[comment handle 
[if hasCreateApiFlag()/?
and handle dependencies to other models
/]
[/file]
[/template]


[template private generateDependsOnForRunCommand(aPackage : EPackage) {packageName : String = aPackage.generatePackageName();}]
[for (pack : EPackage | aPackage.metaModelLibraries()->reject(doNotGenerateEPackage())) ? (not(pack.name = aPackage.name))]
	getRootProject().getTasksByName('build[pack.name.toUpperFirst()/]', true).each { task ->
		dependsOn task
	}
[/for]
[for (libName : String | aPackage.eAllContents()->filter(EClass)->reject(doNotGenerateEClassifier())->select(c : EClass | c.hasKey(keyLibrary())).valueKeys(keyLibrary())->asOrderedSet())]
[if (not (libName.oclIsUndefined() or libName = ''))]
	getRootProject().getTasksByName('build[libName.toUpperFirst()/]', true).each { task ->
		dependsOn task
	}
[/if]
[/for]
[/template]

[template private generateInputsFilesForRunCommand(aPackage : EPackage) {packageName : String = aPackage.generatePackageName();}]
	def allDepOutputs = files()
[for (pack : EPackage | aPackage.metaModelLibraries()->reject(doNotGenerateEPackage())) ? (not(pack.name = aPackage.name))]
	getRootProject().getTasksByName('build[pack.name.toUpperFirst()/]', true).each { task ->
		allDepOutputs.from(task.outputs.files)
	}
[/for]
[for (libName : String | aPackage.eAllContents()->filter(EClass)->reject(doNotGenerateEClassifier())->select(c : EClass | c.hasKey(keyLibrary())).valueKeys(keyLibrary())->asOrderedSet())]
[if (not (libName.oclIsUndefined() or libName = ''))]
	getRootProject().getTasksByName('build[libName.toUpperFirst()/]', true).each { task ->
		allDepOutputs.from(task.outputs.files)
	}
[/if]
[/for]
	inputs.files(allDepOutputs)
[/template]

[template private generateMustRunAfter(aPackage : EPackage) {packageName : String = aPackage.generatePackageName();}]
	mustRunAfter = ['['/]
		'generate[packageName.toUpperFirst()/]'
[for (pack : EPackage | aPackage.metaModelLibraries()->reject(doNotGenerateEPackage())) ? (not(pack.name = aPackage.name))]
		, getRootProject().getTasksByName('compile[pack.name.toUpperFirst()/]', true)
		, getRootProject().getTasksByName('build[pack.name.toUpperFirst()/]', true)
[/for]
[for (libName : String | aPackage.eAllContents()->filter(EClass)->reject(doNotGenerateEClassifier())->select(c : EClass | c.hasKey(keyLibrary())).valueKeys(keyLibrary())->asOrderedSet())]
[if (not (libName.oclIsUndefined() or libName = ''))]
		, getRootProject().getTasksByName('compile[libName.toUpperFirst()/]', true)
		, getRootProject().getTasksByName('build[libName.toUpperFirst()/]', true)
[/if]
[/for]
	[']'/]
[/template]

[template private generatePackageAndFactory(aPackage : EPackage) { packageName : String = aPackage.name; }]	
[aPackage.getNamespacePathWithoutRoot()/]impl/[packageName/]FactoryImpl.cpp
[aPackage.getNamespacePathWithoutRoot()/]impl/[packageName/]PackageImpl.cpp
[aPackage.getNamespacePathWithoutRoot()/]impl/[packageName/]PackageImpl_Creation.cpp
[aPackage.getNamespacePathWithoutRoot()/]impl/[packageName/]PackageImpl_Initialization.cpp
[aPackage.eSubpackages->reject(doNotGenerateEPackage()).generatePackageAndFactory()/]
[/template]


[template private generateAPI(aPackage : EPackage) { packageName : String = aPackage.name; }]	
[aPackage.getNamespacePathWithoutRoot()/]impl/[packageName/]Api.cpp
[/template]

[template private generateCMakeFindLibraryCommands(aPackage : EPackage, ending : String, folderName : String)]
IF (CMAKE_BUILD_TYPE STREQUAL "Debug")
	[generateCMakeFindLibraryCommand(aPackage, ending, folderName, true)/]
ELSE()
	[generateCMakeFindLibraryCommand(aPackage, ending, folderName, false)/]
ENDIF()
[/template]

[query private libraryVariableNameSuffix(debugMode : Boolean) : String = if (debugMode) then 'DEBUG' else 'RELEASE' endif/]
[query private libraryNameSuffix(debugMode : Boolean) : String = if (debugMode) then 'd' else '' endif/]
[query private buildModeCMakeProperty(debugMode : Boolean) : String = if (debugMode) then 'debug' else 'optimized' endif/]

[template private generateCMakeFindLibraryCommand(aPackage : EPackage, ending : String, folderName : String, debugMode : Boolean)]
[for (pack : EPackage | aPackage.metaModelLibraries()->reject(doNotGenerateEPackage())->asOrderedSet()) ? (not(pack.name = aPackage.name))]
FIND_LIBRARY([pack.name.toUpperCase()/]_[libraryVariableNameSuffix(debugMode)/] [pack.name/][libraryNameSuffix(debugMode)/][ending/] ${MDE4CPP_HOME}/application/[folderName/])
[/for]
[for (libName : String | aPackage.eAllContents()->filter(EClass)->reject(doNotGenerateEClassifier())->select(c : EClass | c.hasKey(keyLibrary())).valueKeys(keyLibrary())->asOrderedSet())]
[if (not (libName.oclIsUndefined() or libName = ''))]
FIND_LIBRARY([libName.toUpperCase()/]_[libraryVariableNameSuffix(debugMode)/] [libName/][libraryNameSuffix(debugMode)/][ending/] ${MDE4CPP_HOME}/application/[folderName/])
[/if]
[/for]
[/template]

[template private generateLibraryLinking(aPackage : EPackage, debugMode : Boolean)]
TARGET_LINK_LIBRARIES(${PROJECT_NAME}
[for (pack : EPackage | aPackage.metaModelLibraries()->reject(doNotGenerateEPackage())->asOrderedSet()) ? (not(pack.name = aPackage.name))]
	[buildModeCMakeProperty(debugMode)/] ${[pack.name.toUpperCase()/]_[libraryVariableNameSuffix(debugMode)/]}
[/for]
[for (libName : String | aPackage.eAllContents()->filter(EClass)->reject(doNotGenerateEClassifier())->select(c : EClass | c.hasKey(keyLibrary())).valueKeys(keyLibrary())->asOrderedSet())]
[if (not (libName.oclIsUndefined() or libName = ''))]
	[buildModeCMakeProperty(debugMode)/] ${[libName.toUpperCase()/]_[libraryVariableNameSuffix(debugMode)/]}
[/if]
[/for]
	[if hasCreateApiFlag()]
    [buildModeCMakeProperty(debugMode)/] ws2_32
    [buildModeCMakeProperty(debugMode)/] wsock32
	[/if]
)
[/template]

[template private generateRelatedModelNameList(aPackage : EPackage) post (trim())]
[for (pack : EPackage | aPackage.metaModelLibraries()->sortedBy(name)->reject(doNotGenerateEPackage())) separator (', ') ? (not(pack.name = aPackage.name))]
'[pack.name/]'[/for]
[/template]
